<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TARS Solar System Simulation</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; color: #eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; }
    #hud {
      position: fixed; left: 10px; top: 10px; z-index: 10; padding: 8px 10px;
      background: rgba(0,0,0,0.45); border: 1px solid rgba(255,255,255,0.15); border-radius: 8px;
      line-height: 1.2; font-size: 12px; white-space: pre; user-select: none; max-width: min(92vw, 520px);
    }
    #legend { position: fixed; right: 10px; bottom: 10px; z-index: 10; font-size: 11px; opacity: 0.8; }
    a { color: #8ec7ff; text-decoration: none; }
    .btnbar { margin-top: 6px; display: flex; gap: 4px; flex-wrap: wrap; align-items: center; white-space: normal; }
    .btnbar .row { display: flex; gap: 4px; align-items: center; flex-wrap: wrap; width: 100%; }
    button { background: #1b1f2a; color: #e7eefc; border: 1px solid #2b3140; border-radius: 4px; padding: 3px 6px; cursor: pointer; font-size: 12px; }
    button:active { transform: translateY(1px); }
    select, input[type="number"], input[type="range"] { font-size: 12px; padding: 2px 4px; border-radius: 4px; border: 1px solid #2b3140; background: #0e1117; color: #e7eefc; }
    input[type="range"] { width: 260px; }
    .muted { opacity: 0.8; }
    .ctrl-group { display: inline-grid; grid-template-columns: auto 260px 80px 200px; column-gap: 8px; align-items: center; font-size: 13px; }
    .ctrl-group .row { grid-column: 1 / -1; margin-top: 4px; }
    .ctrl-group .value { display: inline-block; width: 200px; font-variant-numeric: tabular-nums; }
    .tabs { display: flex; gap: 6px; margin-top: 6px; }
    .tab-btn { background: #0e1117; color: #e7eefc; border: 1px solid #2b3140; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 12px; }
    .tab-btn.active { background: #1b1f2a; border-color: #3a4153; }
    .panel { display: none; margin-top: 6px; }
    .panel.active { display: block; }
  </style>
</head>
<body>
  <div id="hud"></div>
  <div id="legend">
    Mouse: drag to orbit • right-drag to pan • wheel to zoom
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "./vendor/three.module.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from './vendor/OrbitControls.js';
    // ---------- High-level simulation parameters ----------
    const AU = 1.0;                // Astronomical Unit in simulation units
    const SCALE = 149597870.7;     // Render units per AU (1 unit = 1 km)
    const YEAR_SECONDS = 365.25 * 24 * 3600; // seconds per Earth year
    const REALTIME_YEARS_PER_SEC = 1 / YEAR_SECONDS; // 1x realtime = this many sim years per real second
    const AU_METERS = 149597870700; // meters per AU
    const C_LIGHT = 299792458; // m/s
    const L_SUN = 3.828e26; // Watts (luminosity of the sun)
    const physics = {
      muSun: (2 * Math.PI) * (2 * Math.PI), // AU^3 / year^2 (Kepler's 3rd law for our units)
      maxDt: 1/3600,               // years
      spinDecay: 0.00,             // small natural decay
      nBodyAttractors: true,       // include planetary gravity on craft/payloads
      
      // New TARS physics
      sailArea: 5000, // m^2 (of one sail, so 2*sailArea total)
      sailLeverArm: 50, // meters (distance from center of mass to center of pressure of one sail)
      sailReflectivityWhite: 0.9,
      sailReflectivityBlack: 0.1,
      payloadMass: 1000, // kg
      tensileStrengthPa: 1000000, // Pa
      tetherCrossSectionalArea: 0.01, // m^2
      tetherMass: 100, // kg
    };
    // Trail sampling (to reduce jitter at low time scales)
    const trailSampling = {
      minYears: 1e-5,        // ~5.26 minutes of sim time
      minDistanceKm: 10000   // 10,000 km between points
    };
    // Screen-space sampling to avoid jitter at close zoom
    const trailScreenSampling = {
      minPixels: 2
    };
    

    // Energy system (arbitrary units)
    // Deprecated constants replaced by physics object above

    // ---------- THREE.js setup ----------
    const epochReal = new Date(); // base real time for simulated datetime derivation
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    // Floating render origin (km) to improve precision at large distances
    const renderOrigin = new THREE.Vector3(0, 0, 0);
    const RENDER_REANCHOR_KM = 5e8; // 500 million km (fewer re-centers)

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.01, 5e12);
    camera.position.set(0, 3e6, 6e6);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 10; // 10 km
    controls.maxDistance = 1e11; // 100 billion km ~ 667 AU

    // ---------- Lighting and background ----------
    const sunLight = new THREE.PointLight(0xffffff, 10, 0, 2);
    sunLight.position.set(0, 0, 0);
    scene.add(sunLight);

    const ambient = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambient);

    // Starfield
    let starfieldMaterialRef = null;
    function createStarfield(count = 2000, radius = 10000 * SCALE) {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        const phi = Math.acos(2 * Math.random() - 1);
        const theta = 2 * Math.PI * Math.random();
        const r = radius * (0.9 + 0.1 * Math.random());
        positions[3*i+0] = r * Math.sin(phi) * Math.cos(theta);
        positions[3*i+1] = r * Math.sin(phi) * Math.sin(theta);
        positions[3*i+2] = r * Math.cos(phi);
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xffffff, size: 3, sizeAttenuation: true });
      starfieldMaterialRef = material;
      const stars = new THREE.Points(geometry, material);
      stars.frustumCulled = false;
      return stars;
    }
    const starfield = createStarfield();
    scene.add(starfield);

    // ---------- Bodies ----------
    class Body {
      constructor({ name, mass, radiusRender, color, semiMajorAU, initialPhase = 0, parent = null }) {
        this.name = name;
        this.mass = mass;               // in Sun mass units for planets? We'll only use Sun's mu for gravity.
        this.radiusRender = radiusRender; // in render units
        this.color = color;
        this.parent = parent;           // Parent body (only Sun for our simplified model)

        // State in AU and AU/year
        const r = semiMajorAU;
        const angle = initialPhase;
        this.position = new THREE.Vector3(r * Math.cos(angle), 0, r * Math.sin(angle));
      const vCircular = Math.sqrt(physics.muSun / r);
        this.velocity = new THREE.Vector3(-vCircular * Math.sin(angle), 0, vCircular * Math.cos(angle));

        // Visuals
        const geom = new THREE.SphereGeometry(Math.max(0.5, radiusRender), 24, 16);
        const mat = new THREE.MeshStandardMaterial({ color: this.color, emissive: 0x000000, metalness: 0.1, roughness: 0.8 });
        this.mesh = new THREE.Mesh(geom, mat);
        scene.add(this.mesh);
      }

      updateVisual() {
        this.mesh.position.set(
          this.position.x * SCALE - renderOrigin.x,
          this.position.y * SCALE - renderOrigin.y,
          this.position.z * SCALE - renderOrigin.z
        );
      }
    }

    function createSun() {
      const sunGeom = new THREE.SphereGeometry(695700, 48, 32);
      const sunTexture = new THREE.TextureLoader().load('./vendor/sun_texture.jpg');
      const sunMat = new THREE.MeshBasicMaterial({ map: sunTexture });
      const sun = new THREE.Mesh(sunGeom, sunMat);
      sun.name = 'Sun';
      sun.userData.baseRenderRadius = sunGeom.parameters.radius;
      scene.add(sun);
      return sun;
    }

    // Sun
    const sun = createSun();

    const hitMarker = new THREE.Mesh(
      new THREE.SphereGeometry(20000, 16, 16), // 10000 km radius
      new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 })
    );
    hitMarker.visible = false;
    scene.add(hitMarker);

    const state = {
      simYears: 0,
      paused: false,
      followTARS: false,
      followOffset: null,
      prevFollowTarget: null,
      showOrbits: true,
      showStarfield: true,
      showLabels: true,
      showTrails: true,

      previewBrightness: 0.7,
      timeScaleMultiplier: 100, // 100x realtime by default
      timeScaleYearsPerSec: 100 * REALTIME_YEARS_PER_SEC,
      focus: 'TARS'
    };
    const autoAimState = {
      running: false,
      targetPlanetName: 'Mars',
      iterations: 0,
      maxIterations: 20000,
      passes: 5,
      searchSpace: 1.0,
      searchSpaceDecay: 0.1,
      best: {
        dist: Infinity,
        vec: new THREE.Vector3(),
        time: 0,
      }
    };
    const allLabels = [];
    const closestApproachLine = new THREE.Line(
        new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
    );
    closestApproachLine.visible = false;
    scene.add(closestApproachLine);

    const ghostPlanet = new THREE.Mesh(
        new THREE.SphereGeometry(1, 24, 16),
        new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 })
    );
    ghostPlanet.visible = false;
    scene.add(ghostPlanet);

    // Gravity well visualization
    const gravityWells = [];
    state.showGravityWells = true;

    // Orbit guide helper (circles)
    const orbitGuides = [];

    function addOrbitGuide(radiusAU, color = 0xffffff, opacity = 0.07) {
      const segments = 512;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(segments * 3);
      for (let i = 0; i < segments; i++) {
        const a = (i / segments) * Math.PI * 2;
        positions[3*i+0] = Math.cos(a) * radiusAU * SCALE;
        positions[3*i+1] = 0;
        positions[3*i+2] = Math.sin(a) * radiusAU * SCALE;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
      const line = new THREE.LineLoop(geometry, material);
      scene.add(line);
      return line;
    }



    // Approx planet mass ratios (Mplanet / MSun)
    const planetMassRatio = {
      Mercury: 1.651e-7,
      Venus:   2.447e-6,
      Earth:   3.003e-6,
      Mars:    3.227e-7,
      Jupiter: 9.5479e-4,
      Saturn:  2.858e-4,
      Uranus:  4.366e-5,
      Neptune: 5.151e-5
    };

    // Planets with approximate semi-major axes (AU) and render radii (exaggerated)
    const planets = [
      { name: 'Mercury', color: 0xaaaaaa, a: 0.39, r: 2439.7 },
      { name: 'Venus',   color: 0xffddaa, a: 0.72, r: 6051.8 },
      { name: 'Earth',   color: 0x4488ff, a: 1.00, r: 6371.0 },
      { name: 'Mars',    color: 0xff6644, a: 1.52, r: 3389.5 },
      { name: 'Jupiter', color: 0xffcc99, a: 5.20, r: 69911 },
      { name: 'Saturn',  color: 0xffeeaa, a: 9.58, r: 58232 },
      { name: 'Uranus',  color: 0xaaffff, a: 19.2, r: 25362 },
      { name: 'Neptune', color: 0x4477ff, a: 30.1, r: 24622 }
    ].map((p, i) => {
      const line = addOrbitGuide(p.a, p.color, 0.06);
      orbitGuides.push(line);
      const body = new Body({ name: p.name, mass: 1, radiusRender: p.r, color: p.color, semiMajorAU: p.a, initialPhase: Math.random() * Math.PI * 2, parent: 'Sun' });
      body.mesh.userData.baseRenderRadius = p.r;

      // Calculate and add gravity well
      const massRatio = planetMassRatio[p.name] || 0;
      const hillRadiusAU = p.a * Math.pow(massRatio / 3, 1/3);
      body.hillRadiusAU = hillRadiusAU; // Storing for preview intersection

      const wellGeom = new THREE.SphereGeometry(hillRadiusAU * SCALE, 32, 16);
      const wellMat = new THREE.MeshBasicMaterial({ color: p.color, transparent: true, opacity: 0.05, wireframe: true });
      const well = new THREE.Mesh(wellGeom, wellMat);
      well.visible = state.showGravityWells;
      body.mesh.add(well);
      gravityWells.push(well);

      return body;
    });

    // Body lookup for focus
    const nameToBody = { Sun: sun, TARS: null };
    for (const p of planets) nameToBody[p.name] = p.mesh;

    // Saturn ring (visual only)
    const saturnIndex = planets.findIndex(p => p.name === 'Saturn');
    if (saturnIndex >= 0) {
      const saturn = planets[saturnIndex];
      const ringGeom = new THREE.RingGeometry(3.6 + 1.2, 3.6 + 2.4, 64);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0xd9c8a0, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
      const ring = new THREE.Mesh(ringGeom, ringMat);
      ring.rotation.x = Math.PI / 2.1;
      saturn.mesh.add(ring);
    }

    // ---------- Simplified gravity (Sun-planet only) ----------
    function sunAccelAUPerYr2(posAU) {
      const r2 = posAU.lengthSq();
      const r = Math.sqrt(r2) + 1e-12;
      return posAU.clone().multiplyScalar(-physics.muSun / (r*r*r));
    }
    function nBodyAccelAUPerYr2(posAU) {
      // Sun term
      const a = sunAccelAUPerYr2(posAU);
      if (!physics.nBodyAttractors) return a;
      // Planetary terms: position of planet relative to Sun is planets[i].position
      for (const p of planets) {
        const m = planetMassRatio[p.name];
        if (!m) continue;
        const rVec = posAU.clone().sub(p.position);
        const r2 = rVec.lengthSq();
        const r = Math.sqrt(r2) + 1e-12;
        // accel = -G Msun mPlanet / r^3 * rhat → here muSun * mPlanet
        a.add(rVec.multiplyScalar(-physics.muSun * m / (r*r*r)));
      }
      return a;
    }
    function integrateSunGravityVerletBody(body, dtYears) {
      // Velocity-Verlet for better energy conservation
      const a0 = sunAccelAUPerYr2(body.position.clone());
      body.velocity.addScaledVector(a0, dtYears * 0.5);
      body.position.addScaledVector(body.velocity, dtYears);
      const a1 = sunAccelAUPerYr2(body.position.clone());
      body.velocity.addScaledVector(a1, dtYears * 0.5);
    }

    // ---------- TARS spacecraft (procedural) ----------
    function createTARS() {
      const root = new THREE.Group();
      const spinNode = new THREE.Group();
      root.add(spinNode);

      // Dimensions
      // Set a plausible physical size for the TARS disc in km (visual only)
      const radius = 0.1;    // 100 meters ~ 0.1 km
      const thickness = 0.02; // 20 meters ~ 0.02 km

      // Geometry container so we can re-orient the disc relative to the spin node
      const geo = new THREE.Group();
      spinNode.add(geo);

      // Side wall of the disc (gray)
      const sideGeom = new THREE.CylinderGeometry(radius, radius, thickness, 64, 1, true);
      const sideMat = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.4, roughness: 0.6 });
      const side = new THREE.Mesh(sideGeom, sideMat);
      geo.add(side);

      // Top and bottom halves (black / white)
      const halfA = new THREE.Mesh(
        new THREE.CircleGeometry(radius, 64, 0, Math.PI),
        new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.2, roughness: 0.9 })
      );
      const halfB = new THREE.Mesh(
        new THREE.CircleGeometry(radius, 64, Math.PI, Math.PI),
        new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.2, roughness: 0.9 })
      );
      const top = new THREE.Group();
      halfA.rotation.x = -Math.PI / 2;
      halfB.rotation.x = -Math.PI / 2;
      halfA.position.y = thickness / 2;
      halfB.position.y = thickness / 2;
      top.add(halfA); top.add(halfB);
      geo.add(top);

      // Bottom mirrors
      const halfA2 = halfA.clone(); halfA2.material = halfA.material.clone();
      const halfB2 = halfB.clone(); halfB2.material = halfB.material.clone();
      halfA2.rotation.x = Math.PI / 2;
      halfB2.rotation.x = Math.PI / 2;
      halfA2.position.y = -thickness / 2;
      halfB2.position.y = -thickness / 2;
      const bottom = new THREE.Group(); bottom.add(halfA2); bottom.add(halfB2);
      geo.add(bottom);

      // Make the disc an oval by non-uniform scaling
      geo.scale.set(1.8, 1.0, 1.1);

      // Subtle emissive seam along the color divide (optional visual)
      const seam = new THREE.Mesh(new THREE.PlaneGeometry(2 * radius, thickness * 1.05), new THREE.MeshBasicMaterial({ color: 0x222222 }));
      seam.rotation.y = Math.PI / 2;
      geo.add(seam);

      // Keep disc HORIZONTAL relative to spinNode (normal along local Y)
      geo.rotation.x = 0;
      geo.rotation.y = 0;
      geo.rotation.z = Math.PI/2;

      // Axis helper (hidden by default)
      const axis = new THREE.AxesHelper(2.0); axis.visible = false; root.add(axis);
      root.userData.spinNode = spinNode;
      return root;
    }

    const tars = {
      name: 'TARS',
      // Physical state in AU and AU/year
      position: new THREE.Vector3(1.0, 0, 0.01), // near Earth's orbit
      velocity: new THREE.Vector3(0, 0, 0),
      lastExitVelocityMps: 0.0,
      spin: 0.0, // radians per second (visual)
      spinPhase: 0.0, // accumulated radians for visual rotation
      mesh: createTARS()
    };
    scene.add(tars.mesh);
    nameToBody.TARS = tars.mesh;

    // ---------- Object registry: payloads & markers ----------
    const simObjects = {
      payloads: [], // { id, position(AU), velocity(AU/yr), mesh, label, trail, color }
      markers: [],   // { id, position(AU), mesh, label }
      asteroids: [] 
    };
    let nextObjectId = 1;





    function integrateSunGravityVecVerlet(positionAU, velocityAUPerYr, dtYears) {
      const a0 = nBodyAccelAUPerYr2(positionAU.clone());
      velocityAUPerYr.addScaledVector(a0, dtYears * 0.5);
      positionAU.addScaledVector(velocityAUPerYr, dtYears);
      const a1 = nBodyAccelAUPerYr2(positionAU.clone());
      velocityAUPerYr.addScaledVector(a1, dtYears * 0.5);
    }

    function createSmallTrail(maxPoints, color) {
      const positions = new Float32Array(maxPoints * 3);
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setDrawRange(0, 0);
      const material = new THREE.LineDashedMaterial({ color, transparent: true, opacity: 0.7, dashSize: 2, gapSize: 1 });
      const line = new THREE.Line(geometry, material);
      line.computeLineDistances();
      line.frustumCulled = false;
      return { line, positions, geometry, maxPoints, count: 0 };
    }
    const tarsTrail = createTrail(2000, 0x66ccff);
    scene.add(tarsTrail.line);
    // Add head connector for TARS trail
    if (tarsTrail.headLine) scene.add(tarsTrail.headLine);

    function appendToSmallTrail(trail, posWorld) {
      const { positions, maxPoints } = trail;
      if (trail.count < maxPoints) {
        const idx = trail.count;
        positions[idx*3+0] = posWorld.x;
        positions[idx*3+1] = posWorld.y;
        positions[idx*3+2] = posWorld.z;
        trail.count++;
      } else {
        positions.copyWithin(0, 3);
        positions[positions.length-3] = posWorld.x;
        positions[positions.length-2] = posWorld.y;
        positions[positions.length-1] = posWorld.z;
      }
      trail.geometry.attributes.position.needsUpdate = true;
      trail.geometry.setDrawRange(0, trail.count);
    }

    function spawnPayload(init) {
      const id = `payload_${nextObjectId++}`;
      const color = init.color != null ? init.color : 0x66ff88;
      const geom = new THREE.SphereGeometry(0.4, 16, 12);
      const mat = new THREE.MeshStandardMaterial({ color, emissive: 0x001100, metalness: 0.1, roughness: 0.7 });
      const mesh = new THREE.Mesh(geom, mat);
      scene.add(mesh);
      const label = createLabelSprite('Payload');
      label.position.set(0, 1.2, 0);
      label.visible = state.showLabels;
      mesh.add(label);

      const payload = {
        id,
        position: init.position.clone(),
        velocity: init.velocity.clone(),
        mesh,
        label,
        color,
        trail: createTrail(600, color)
      };
      scene.add(payload.trail.line);
      payload.trail.line.visible = state.showTrails;
      if (payload.trail.headLine) {
        scene.add(payload.trail.headLine);
        payload.trail.headLine.visible = state.showTrails;
      }
      simObjects.payloads.push(payload);
      return id;
    }

    function spawnMarker(init) {
      const id = `marker_${nextObjectId++}`;
      const color = init.color != null ? init.color : 0xffaa00;
      const geom = new THREE.SphereGeometry(0.25, 12, 10);
      const mat = new THREE.MeshBasicMaterial({ color });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(init.position.x * SCALE, init.position.y * SCALE, init.position.z * SCALE);
      scene.add(mesh);
      const label = createLabelSprite(init.label || 'Target');
      label.position.set(0, 0.9, 0);
      label.visible = state.showLabels;
      mesh.add(label);
      const marker = { id, position: init.position.clone(), mesh, label };
      simObjects.markers.push(marker);
      return id;
    }

    function despawnById(id) {
      const pIdx = simObjects.payloads.findIndex(o => o.id === id);
      if (pIdx >= 0) {
        const p = simObjects.payloads[pIdx];
        scene.remove(p.mesh);
        scene.remove(p.trail.line);
        p.mesh.geometry.dispose(); p.mesh.material.dispose();
        simObjects.payloads.splice(pIdx, 1);

        delete nameToBody[id];
        const opt = focusSelect.querySelector(`option[value="${id}"]`);
        if (opt) {
          focusSelect.removeChild(opt);
        }
        if (state.focus === id) {
          state.focus = 'TARS';
          focusSelect.value = 'TARS';
          frameFocus(true);
        }

        return true;
      }
      const mIdx = simObjects.markers.findIndex(o => o.id === id);
      if (mIdx >= 0) {
        const m = simObjects.markers[mIdx];
        scene.remove(m.mesh);
        m.mesh.geometry.dispose(); m.mesh.material.dispose();
        simObjects.markers.splice(mIdx, 1);
        return true;
      }
      const aIdx = simObjects.asteroids.findIndex(o => o.id === id);
      if (aIdx >= 0) {
        const a = simObjects.asteroids[aIdx];
        scene.remove(a.mesh);
        scene.remove(a.trail.line);
        a.mesh.geometry.dispose(); a.mesh.material.dispose();
        simObjects.asteroids.splice(aIdx, 1);
        return true;
      }
      return false;
    }

    function updatePayloads(dtYears) {
      for (const p of simObjects.payloads) {
        integrateSunGravityVecVerlet(p.position, p.velocity, dtYears);
      }
    }

    // TARS trail
    function createTrail(maxPoints, color) {
      // Main trail polyline (stored in local coordinates relative to an anchor)
      const positions = new Float32Array(maxPoints * 3);
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setDrawRange(0, 0);
      const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.7 });
      const line = new THREE.Line(geometry, material);
      line.frustumCulled = false;

      // Head connector: from last trail point to current position (also local coordinates)
      const headPositions = new Float32Array(2 * 3);
      const headGeometry = new THREE.BufferGeometry();
      headGeometry.setAttribute('position', new THREE.BufferAttribute(headPositions, 3));
      headGeometry.setDrawRange(0, 0);
      const headMaterial = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.9 });
      const headLine = new THREE.Line(headGeometry, headMaterial);
      headLine.frustumCulled = false;

      return {
        line,
        positions,
        geometry,
        maxPoints,
        count: 0,
        headLine,
        headPositions,
        headGeometry,
        // floating origin anchor in km, to keep vertex coordinates near zero
        anchor: new THREE.Vector3(0, 0, 0),
        anchorInitialized: false,
        reanchorDistanceKm: 5e7 // 50 million km
      };
    }
    function appendToTrail(trail, v3WorldKm) {
      // Initialize anchor at first point
      if (!trail.anchorInitialized) {
        trail.anchor.copy(v3WorldKm);
        {
          const localAnchor = trail.anchor.clone().sub(renderOrigin);
          trail.line.position.copy(localAnchor);
          if (trail.headLine) trail.headLine.position.copy(localAnchor);
        }
        trail.anchorInitialized = true;
      }
      // Re-anchor if distance from anchor grows too large
      let offset = new THREE.Vector3().copy(v3WorldKm).sub(trail.anchor);
      if (offset.length() > (trail.reanchorDistanceKm || 5e7)) {
        const delta = new THREE.Vector3().copy(v3WorldKm).sub(trail.anchor);
        trail.anchor.copy(v3WorldKm);
        {
          const localAnchor = trail.anchor.clone().sub(renderOrigin);
          trail.line.position.copy(localAnchor);
          if (trail.headLine) trail.headLine.position.copy(localAnchor);
        }
        // Shift existing vertices by -delta to keep them near origin
        for (let i = 0; i < trail.count; i++) {
          const j = i * 3;
          trail.positions[j+0] -= delta.x;
          trail.positions[j+1] -= delta.y;
          trail.positions[j+2] -= delta.z;
        }
        if (trail.headPositions && trail.headGeometry.drawRange.count > 0) {
          trail.headPositions[0] -= delta.x;
          trail.headPositions[1] -= delta.y;
          trail.headPositions[2] -= delta.z;
        }
        // Recompute local offset relative to new anchor
        offset.set(0, 0, 0);
      }
      const { positions, maxPoints } = trail;
      // Optional screen-space sampling: skip if projected movement is tiny
      if (trailScreenSampling && camera && renderer && trail.count > 0) {
        const lastIdx = (trail.count - 1) * 3;
        const lastLocal = new THREE.Vector3(
          positions[lastIdx+0], positions[lastIdx+1], positions[lastIdx+2]
        );
        const currLocal = offset.clone();
        const lastWorld = lastLocal.clone().add(trail.anchor);
        const currWorld = currLocal.clone().add(trail.anchor);
        const lastNdc = lastWorld.clone().project(camera);
        const currNdc = currWorld.clone().project(camera);
        const w = renderer.domElement.width, h = renderer.domElement.height;
        const lastPx = new THREE.Vector2((lastNdc.x * 0.5 + 0.5) * w, ( -lastNdc.y * 0.5 + 0.5) * h);
        const currPx = new THREE.Vector2((currNdc.x * 0.5 + 0.5) * w, ( -currNdc.y * 0.5 + 0.5) * h);
        if (lastPx.distanceTo(currPx) < (trailScreenSampling.minPixels || 2)) {
          // Still update head connector, but skip adding a new vertex
          if (trail.headPositions && trail.count > 0) {
            const hp = trail.headPositions;
            hp[0] = positions[lastIdx+0];
            hp[1] = positions[lastIdx+1];
            hp[2] = positions[lastIdx+2];
            hp[3] = currLocal.x;
            hp[4] = currLocal.y;
            hp[5] = currLocal.z;
            trail.headGeometry.attributes.position.needsUpdate = true;
            trail.headGeometry.setDrawRange(0, 2);
          }
          return;
        }
      }
      if (trail.count < maxPoints) {
        const idx = trail.count;
        positions[idx*3+0] = offset.x;
        positions[idx*3+1] = offset.y;
        positions[idx*3+2] = offset.z;
        trail.count++;
      } else {
        positions.copyWithin(0, 3);
        positions[positions.length-3] = offset.x;
        positions[positions.length-2] = offset.y;
        positions[positions.length-1] = offset.z;
      }
      trail.geometry.attributes.position.needsUpdate = true;
      trail.geometry.setDrawRange(0, trail.count);
    }

    // ---------- Trajectory preview (payload) ----------
    function createPreviewLine(maxPoints, color) {
      const positions = new Float32Array(maxPoints * 3);
      const colors = new Float32Array(maxPoints * 3);
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setDrawRange(0, 0);
      const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.8, vertexColors: true });
      const line = new THREE.Line(geometry, material);
      line.frustumCulled = false;
      return { line, positions, geometry, maxPoints, colors };
    }
    const preview = {
      enabled: false,
      horizonYears: 0.5, // ~6 months
      steps: 300,
      dirty: true,
      payload: createPreviewLine(2000, 0x44ff77)
    };
    scene.add(preview.payload.line);
    preview.payload.line.visible = false;

    function calculateAllPlanetAccels(planetStates) {
        const accels = planetStates.map(() => new THREE.Vector3());
        const rVec = new THREE.Vector3(); // reuse this vector

        // Sun gravity
        for (let i = 0; i < planetStates.length; i++) {
            accels[i].copy(sunAccelAUPerYr2(planetStates[i].pos));
        }

        if (!physics.nBodyAttractors) return accels;

        // Planet-planet gravity
        for (let i = 0; i < planetStates.length; i++) {
            for (let j = i + 1; j < planetStates.length; j++) {
                const body1 = planetStates[i];
                const body2 = planetStates[j];
                const m1_ratio = planetMassRatio[body1.name];
                const m2_ratio = planetMassRatio[body2.name];
                if (!m1_ratio || !m2_ratio) continue;

                rVec.subVectors(body1.pos, body2.pos);
                const r2 = rVec.lengthSq();
                const r = Math.sqrt(r2) + 1e-12;
                const r3_inv = 1 / (r*r*r);

                // acc on body1 from body2
                accels[i].addScaledVector(rVec, -physics.muSun * m2_ratio * r3_inv);
                // acc on body2 from body1
                accels[j].addScaledVector(rVec, physics.muSun * m1_ratio * r3_inv);
            }
        }
        return accels;
    }

    function calculateTrajectory(launchVec) {
      const steps = Math.max(2, Math.min(preview.steps, preview.payload.maxPoints));
      const dt = preview.horizonYears / (steps - 1);
      const startPos = tars.position.clone();
      const dir = launchVec.clone().normalize();
      const v_mps = physics.sailLeverArm * tars.spin;
      const dvAUPerYr = mpsToAUPerYr(v_mps);
      const startVel = tars.velocity.clone().addScaledVector(dir, dvAUPerYr);
      let p = startPos.clone();
      let v = startVel.clone();
      const planetStates = planets.map(pl => ({ name: pl.name, pos: pl.position.clone(), vel: pl.velocity.clone(), hillRadiusAU: pl.hillRadiusAU }));
      let closestApproach = {
        distanceSq: Infinity,
        payloadPos: null,
        payloadVel: null,
        planetPos: null,
        planetVel: null,
      };

      function localAccel(posAU) {
        const r2 = posAU.lengthSq();
        const r = Math.sqrt(r2) + 1e-12;
        const a = posAU.clone().multiplyScalar(-physics.muSun / (r*r*r));
        if (!physics.nBodyAttractors) return a;
        for (const st of planetStates) {
          const m = planetMassRatio[st.name]; if (!m) continue;
          const rp = posAU.clone().sub(st.pos);
          const r2p = rp.lengthSq();
          const rpLen = Math.sqrt(r2p) + 1e-12;
          a.add(rp.multiplyScalar(-physics.muSun * m / (rpLen*rpLen*rpLen)));
        }
        return a;
      }

      for (let i = 0; i < steps; i++) {
        const targetPlanetState = planetStates.find(st => st.name === autoAimState.targetPlanetName);
        if (targetPlanetState) {
            const distanceSq = p.distanceToSquared(targetPlanetState.pos);
            if (distanceSq < closestApproach.distanceSq) {
                closestApproach.distanceSq = distanceSq;
                closestApproach.payloadPos = p.clone();
                closestApproach.payloadVel = v.clone();
                closestApproach.planetPos = targetPlanetState.pos.clone();
                closestApproach.planetVel = targetPlanetState.vel.clone();
            }
        }

        const a0 = localAccel(p.clone());
        v.addScaledVector(a0, dt * 0.5);
        p.addScaledVector(v, dt);
        const a1 = localAccel(p.clone());
        v.addScaledVector(a1, dt * 0.5);
        
        const planetAccels = calculateAllPlanetAccels(planetStates);

        for (let j = 0; j < planetStates.length; j++) {
          const st = planetStates[j];
          const a0p = planetAccels[j];
          st.vel.addScaledVector(a0p, dt * 0.5);
          st.pos.addScaledVector(st.vel, dt);
        }

        const newPlanetAccels = calculateAllPlanetAccels(planetStates);

        for (let j = 0; j < planetStates.length; j++) {
          const st = planetStates[j];
          const a1p = newPlanetAccels[j];
          st.vel.addScaledVector(a1p, dt * 0.5);
        }
      }
      return closestApproach;
    }

    function computePayloadPreview() {
      hitMarker.visible = false;
      closestApproachLine.visible = false;
      ghostPlanet.visible = false;
      if (!preview.enabled) document.getElementById('preview-info').textContent = '';

      const positions = preview.payload.positions;
      const colors = preview.payload.colors;
      const steps = Math.max(2, Math.min(preview.steps, preview.payload.maxPoints));
      const dt = preview.horizonYears / (steps - 1);
      // Start from TARS with hypothetical release DV (vector-only)
      const startPos = tars.position.clone();
      const dir = new THREE.Vector3(payloadState.vecX, payloadState.vecY, payloadState.vecZ).normalize();
      const v_mps = physics.sailLeverArm * tars.spin;
      const dvAUPerYr = mpsToAUPerYr(v_mps);
      const startVel = tars.velocity.clone().addScaledVector(dir, dvAUPerYr);
      let p = startPos.clone();
      let v = startVel.clone();
      // Snapshot planet states (position in AU) and integrate them for consistent N-body preview
      const planetStates = planets.map(pl => ({ name: pl.name, pos: pl.position.clone(), vel: pl.velocity.clone(), hillRadiusAU: pl.hillRadiusAU }));
      
      let closestApproaches = planets.map(pl => ({
        planetName: pl.name,
        distanceSq: Infinity,
        payloadPos: null,
        payloadVel: null,
        planetPos: null,
        planetVel: null,
        step: -1,
      }));

      function localAccel(posAU) {
        // Sun term
        const r2 = posAU.lengthSq();
        const r = Math.sqrt(r2) + 1e-12;
        const a = posAU.clone().multiplyScalar(-physics.muSun / (r*r*r));
        if (!physics.nBodyAttractors) return a;
        for (const st of planetStates) {
          const m = planetMassRatio[st.name]; if (!m) continue;
          const rp = posAU.clone().sub(st.pos);
          const r2p = rp.lengthSq();
          const rpLen = Math.sqrt(r2p) + 1e-12;
          a.add(rp.multiplyScalar(-physics.muSun * m / (rpLen*rpLen*rpLen)));
        }
        return a;
      }

      let hitStep = -1;
      let hitPlanetName = '';

      let p_old = p.clone();
      let planetStates_old = planetStates.map(st => ({...st, pos: st.pos.clone(), vel: st.vel.clone()}));

      for (let i = 0; i < steps; i++) {
        // write world positions in render units
        positions[i*3+0] = p.x * SCALE;
        positions[i*3+1] = p.y * SCALE;
        positions[i*3+2] = p.z * SCALE;

        // coloring
        const speed = v.length();
        const color = new THREE.Color();
        const t = Math.min(1, speed / 1.5); // Normalize speed to [0, 1] for color, adjusted for better range
        color.setHSL(t * 0.33, 1.0, Math.max(0.3, state.previewBrightness));
        colors[i*3+0] = color.r;
        colors[i*3+1] = color.g;
        colors[i*3+2] = color.b;

        p_old.copy(p);
        planetStates_old = planetStates.map(st => ({...st, pos: st.pos.clone(), vel: st.vel.clone()}));

        // advance one step with velocity-Verlet using local N-body accel
        const a0 = localAccel(p.clone());
        v.addScaledVector(a0, dt * 0.5);
        p.addScaledVector(v, dt);
        const a1 = localAccel(p.clone());
        v.addScaledVector(a1, dt * 0.5);
        
        // advance planet states with N-body gravity
        const planetAccels = calculateAllPlanetAccels(planetStates);
        for (let j = 0; j < planetStates.length; j++) {
          const st = planetStates[j];
          const a0p = planetAccels[j];
          st.vel.addScaledVector(a0p, dt * 0.5);
          st.pos.addScaledVector(st.vel, dt);
        }
        const newPlanetAccels = calculateAllPlanetAccels(planetStates);
        for (let j = 0; j < planetStates.length; j++) {
          const st = planetStates[j];
          const a1p = newPlanetAccels[j];
          st.vel.addScaledVector(a1p, dt * 0.5);
        }

        // Check for intersection and closest approach
        for (let j = 0; j < planetStates.length; j++) {
            const st = planetStates[j];
            const distanceSq = p.distanceToSquared(st.pos);
            if (distanceSq < closestApproaches[j].distanceSq) {
                closestApproaches[j].distanceSq = distanceSq;
                closestApproaches[j].payloadPos = p.clone();
                closestApproaches[j].payloadVel = v.clone();
                closestApproaches[j].planetPos = st.pos.clone();
                closestApproaches[j].planetVel = st.vel.clone();
                closestApproaches[j].step = i;
            }
            const planetRadiusAU = (planetRadiusKm[st.name] || 0) / KM_PER_AU;
            if (hitStep === -1 && planetRadiusAU > 0 && distanceSq < planetRadiusAU * planetRadiusAU) {
                // Refine impact
                let low = 0.0, high = 1.0;
                let impactT = 1.0;
                for(let k=0; k<5; k++) {
                    const mid = (low + high) / 2;
                    const p_interp = p_old.clone().lerp(p, mid);
                    const planet_pos_interp = planetStates_old[j].pos.clone().lerp(st.pos, mid);
                    if (p_interp.distanceToSquared(planet_pos_interp) < planetRadiusAU * planetRadiusAU) {
                        high = mid;
                    } else {
                        low = mid;
                    }
                }
                impactT = high;

                hitStep = i - 1 + impactT;
                hitPlanetName = st.name;
                const p_impact = p_old.clone().lerp(p, impactT);
                hitMarker.position.set(p_impact.x * SCALE, p_impact.y * SCALE, p_impact.z * SCALE);
                hitMarker.visible = true;
                p.copy(p_impact); // Stop payload at impact point
            }
        }

        if (hitStep !== -1) {
          break;
        }
      }
      preview.payload.geometry.attributes.position.needsUpdate = true;
      preview.payload.geometry.attributes.color.needsUpdate = true;
      const drawCount = (hitStep !== -1) ? hitStep + 1 : steps;
      preview.payload.geometry.setDrawRange(0, drawCount);

      // Update HUD
      const previewInfo = document.getElementById('preview-info');
      if (hitStep !== -1) {
          const hitApproach = closestApproaches.find(a => a.planetName === hitPlanetName);
          const relVel = new THREE.Vector3().subVectors(hitApproach.payloadVel, hitApproach.planetVel);
          const relSpeedMps = auPerYrToMps(relVel.length());
          const days = hitStep * dt * 365.25;
          // Also compute closest approach timing for display
          let overallClosest = { distanceSq: Infinity };
          for (const approach of closestApproaches) {
              if (approach.distanceSq < overallClosest.distanceSq) {
                  overallClosest = approach;
              }
          }
          let closestPart = '';
          if (overallClosest && overallClosest.step != null && overallClosest.step >= 0) {
            const caDays = overallClosest.step * dt * 365.25;
            closestPart = ` • Closest approach: ${overallClosest.planetName} at ${caDays.toFixed(1)} days`;
          }
          if (!preview.enabled) previewInfo.textContent = `Impact: ${hitPlanetName} at ${relSpeedMps.toFixed(0)} m/s ${days.toFixed(1)} days${closestPart}`;
      } else {
          let overallClosest = { distanceSq: Infinity };
          for (const approach of closestApproaches) {
              if (approach.distanceSq < overallClosest.distanceSq) {
                  overallClosest = approach;
              }
          }
          if (overallClosest.payloadPos) {
              const line_positions = new Float32Array(6);
              line_positions[0] = overallClosest.payloadPos.x * SCALE;
              line_positions[1] = overallClosest.payloadPos.y * SCALE;
              line_positions[2] = overallClosest.payloadPos.z * SCALE;
              line_positions[3] = overallClosest.planetPos.x * SCALE;
              line_positions[4] = overallClosest.planetPos.y * SCALE;
              line_positions[5] = overallClosest.planetPos.z * SCALE;
              closestApproachLine.geometry.setAttribute('position', new THREE.BufferAttribute(line_positions, 3));
              closestApproachLine.geometry.computeBoundingSphere();
              if (preview.enabled) closestApproachLine.visible = true;

              const planet = planets.find(p => p.name === overallClosest.planetName);
              if (planet) {
                  ghostPlanet.geometry = planet.mesh.geometry.clone();
                  ghostPlanet.material.color.set(planet.color);
                  ghostPlanet.position.set(
                      overallClosest.planetPos.x * SCALE - renderOrigin.x,
                      overallClosest.planetPos.y * SCALE - renderOrigin.y,
                      overallClosest.planetPos.z * SCALE - renderOrigin.z
                  );
                  ghostPlanet.scale.copy(planet.mesh.scale);
                  if (preview.enabled) ghostPlanet.visible = true;
              }

              const relVel = new THREE.Vector3().subVectors(overallClosest.payloadVel, overallClosest.planetVel);
              const relSpeedMps = auPerYrToMps(relVel.length());
              const distKm = Math.sqrt(overallClosest.distanceSq) * SCALE;
              const days = (overallClosest.step !== undefined && overallClosest.step >= 0) ? (overallClosest.step * dt * 365.25) : -1;
              if (days >= 0) {
                previewInfo.textContent = `Closest approach: ${overallClosest.planetName} in ${days.toFixed(1)} days (${distKm.toExponential(2)} km at ${relSpeedMps.toFixed(0)} m/s)`;
              } else {
                previewInfo.textContent = `Closest approach: ${overallClosest.planetName} (${distKm.toExponential(2)} km at ${relSpeedMps.toFixed(0)} m/s)`;
              }
          }
      }

      preview.dirty = false;
    }

    function updateTars(dtYears) {
      // Gravity from Sun (Velocity-Verlet)
      const a0 = nBodyAccelAUPerYr2(tars.position.clone());
      tars.velocity.addScaledVector(a0, dtYears * 0.5);
      tars.position.addScaledVector(tars.velocity, dtYears);
      const a1 = nBodyAccelAUPerYr2(tars.position.clone());
      tars.velocity.addScaledVector(a1, dtYears * 0.5);

      // Spin gain from solar radiation pressure
      const r_AU = tars.position.length();
      const r_m = r_AU * AU_METERS;
      const solarIrradiance = L_SUN / (4 * Math.PI * r_m * r_m); // W/m^2

      const force_white = (solarIrradiance / C_LIGHT) * physics.sailArea * (1 + physics.sailReflectivityWhite);
      const force_black = (solarIrradiance / C_LIGHT) * physics.sailArea * (1 + physics.sailReflectivityBlack);
      
      const torque = (force_white - force_black) * physics.sailLeverArm; // N*m
      
      const momentOfInertia = (physics.payloadMass + physics.payloadMass + physics.tetherMass) * physics.sailLeverArm * physics.sailLeverArm;
      const angular_acceleration = torque / momentOfInertia; // rad/s^2
      
      const dtSeconds = dtYears * YEAR_SECONDS;
      tars.spin += angular_acceleration * dtSeconds;

      // Natural spin decay
      tars.spin = Math.max(0, tars.spin - physics.spinDecay * dtYears);

      const gForce = (tars.spin * tars.spin * physics.sailLeverArm) / 9.8;
      const tensileForce = physics.payloadMass * gForce * 9.8;
      const tensilePressure = tensileForce / physics.tetherCrossSectionalArea;
      if (tensilePressure > physics.tensileStrengthPa) {
        handleStructuralFailure();
      }

    }

    function handleStructuralFailure() {
      flashHudMessage('TARS structural failure due to excessive tensile pressure!');
      tars.spin = 0;
      const randomDirection = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
      releasePayloadNow(randomDirection);
    }

    // Initialize TARS orbital velocity for near-circular orbit at its radius
    (function initTarsVelocity() {
      const r = Math.sqrt(tars.position.lengthSq());
      const v = Math.sqrt(physics.muSun / r);
      // Tangential to radius in +theta direction
      const dir = new THREE.Vector3(-tars.position.z, 0, tars.position.x).normalize();
      tars.velocity.copy(dir.multiplyScalar(v));
    })();

    // ---------- HUD ----------
    const hud = document.getElementById('hud');
    const hudStats = document.createElement('div');
    hud.appendChild(hudStats);
    const hudMsg = document.createElement('div');
    hudMsg.style.marginTop = '6px';
    hudMsg.style.color = '#ffd166';
    hudMsg.style.fontStyle = 'italic';
    hud.appendChild(hudMsg);
    const previewInfo = document.createElement('div');
    previewInfo.id = 'preview-info';
    previewInfo.style.marginTop = '6px';
    previewInfo.style.color = '#66ccff';
    hud.appendChild(previewInfo);
    function flashHudMessage(msg) {
      hudMsg.textContent = msg;
      clearTimeout(hudMsg._t);
      hudMsg._t = setTimeout(() => { hudMsg.textContent = ''; }, 1200);
    }

    function updateHUD() {
      const r = Math.sqrt(tars.position.lengthSq());
      const realNow = new Date();
      const simMillis = epochReal.getTime() + state.simYears * YEAR_SECONDS * 1000;
      const simDate = new Date(simMillis);
      const tipScale = (typeof payloadState !== 'undefined' && payloadState && Number.isFinite(payloadState.tipScaleMSPerRad)) ? payloadState.tipScaleMSPerRad : 10;
      const tipSpeedMps = Math.max(0, tars.spin) * tipScale;
      const gForce = (tars.spin * tars.spin * physics.sailLeverArm) / 9.8;
      const potential_v_mps = physics.sailLeverArm * tars.spin;
      hudStats.textContent = `Real time: ${realNow.toLocaleString()}
` +
        `Sim time: ${simDate.toLocaleString()} (Δ ${state.simYears.toFixed(2)} years)
` +
        `TARS @ ${r.toFixed(3)} AU
` +
        `Exit velocity (last): ${tars.lastExitVelocityMps.toFixed(2)} m/s
` +
        `Potential exit velocity: ${(potential_v_mps/1000).toFixed(2)} km/s
` +
        `Tip speed: ${tipSpeedMps.toFixed(1)} m/s
` +
        `G-force: ${gForce.toFixed(2)} G
` +
        `Tensile Force (${physics.payloadMass}kg payload): ${(physics.payloadMass * gForce * 9.8).toLocaleString()} N
` +
        `Tensile Pressure: ${(physics.payloadMass * gForce * 9.8 / physics.tetherCrossSectionalArea).toLocaleString()} Pa
` +
        `Spin: ${tars.spin.toFixed(3)} rad/s (${(tars.spin * 60 / (2 * Math.PI)).toFixed(2)} RPM)
` +
        `Time scale: ${state.timeScaleMultiplier.toLocaleString()}x realtime (${state.timeScaleYearsPerSec.toExponential(3)} y/s)
` +
        `Focus: ${state.focus}`;
    }

    // Buttons
    const tabs = document.createElement('div'); tabs.className = 'tabs';
    const tabControls = document.createElement('button'); tabControls.className = 'tab-btn active'; tabControls.textContent = 'Controls';
    const tabPhysics = document.createElement('button'); tabPhysics.className = 'tab-btn'; tabPhysics.textContent = 'Physics';
    const tabGraphics = document.createElement('button'); tabGraphics.className = 'tab-btn'; tabGraphics.textContent = 'Graphics';
    const tabLaunch = document.createElement('button'); tabLaunch.className = 'tab-btn'; tabLaunch.textContent = 'Payload';
    const tabTargets = document.createElement('button'); tabTargets.className = 'tab-btn'; tabTargets.textContent = 'Targets';
    tabs.appendChild(tabControls); tabs.appendChild(tabPhysics); tabs.appendChild(tabGraphics); tabs.appendChild(tabLaunch); tabs.appendChild(tabTargets);
    hud.appendChild(tabs);

    const panelControls = document.createElement('div'); panelControls.className = 'panel active';
    const panelPhysics = document.createElement('div'); panelPhysics.className = 'panel';
    const panelGraphics = document.createElement('div'); panelGraphics.className = 'panel';
    const panelLaunch = document.createElement('div'); panelLaunch.className = 'panel';
    const panelTargets = document.createElement('div'); panelTargets.className = 'panel';
    hud.appendChild(panelControls);
    hud.appendChild(panelPhysics);
    hud.appendChild(panelGraphics);
    hud.appendChild(panelLaunch);
    hud.appendChild(panelTargets);

    const btnBar = document.createElement('div');
    btnBar.className = 'btnbar';
    const btnStart = document.createElement('button'); btnStart.textContent = 'Start';
    const btnPause = document.createElement('button'); btnPause.textContent = 'Pause';
    const btnStop = document.createElement('button'); btnStop.textContent = 'Stop';
    const btnFollow = document.createElement('button'); btnFollow.textContent = 'Follow On/Off';
    const btnFaster = document.createElement('button'); btnFaster.textContent = 'Faster';
    const btnSlower = document.createElement('button'); btnSlower.textContent = 'Slower';
    const btnSpin = document.createElement('button'); btnSpin.textContent = 'Boost Spin';
    const btnOrbits = document.createElement('button'); btnOrbits.textContent = 'Toggle Orbits';
    const btnStars = document.createElement('button'); btnStars.textContent = 'Toggle Stars';
    const btnLabels = document.createElement('button'); btnLabels.textContent = 'Toggle Labels';
    const btnTrails = document.createElement('button'); btnTrails.textContent = 'Toggle Trails';
    const btnWells = document.createElement('button'); btnWells.textContent = 'Toggle Wells';
    const btnResetView = document.createElement('button'); btnResetView.textContent = 'Reset View';

    const autoAimForm = document.createElement('div'); autoAimForm.className = 'btnbar';
    const autoAimRow = document.createElement('div'); autoAimRow.className = 'row';
    const autoAimLabel = document.createElement('label'); autoAimLabel.textContent = 'Target Planet:';
    const autoAimSelect = document.createElement('select');
    for (const name of ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']) {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      if (name === 'Mars') opt.selected = true;
      autoAimSelect.appendChild(opt);
    }
    const autoAimBtn = document.createElement('button'); autoAimBtn.textContent = 'Auto-Aim';
    autoAimBtn.style.backgroundColor = '#22c55e';
    autoAimBtn.onclick = () => {
      if (autoAimState.running) return;
      autoAimState.running = true;
      autoAimState.targetPlanetName = autoAimSelect.value;
      autoAimState.iterations = 0;
      autoAimState.best.dist = Infinity;
      autoAimBtn.style.display = 'none';
      autoAimCancelBtn.style.display = 'inline-block';
      autoAimInfo.textContent = `Searching for trajectory to ${autoAimState.targetPlanetName}...`;

      const learningRate = 0.01; // Reduced learning rate for stability with momentum
      const epsilon = 1e-6;
      const momentum = 0.9;
      let currentVec = new THREE.Vector3(payloadState.vecX, payloadState.vecY, payloadState.vecZ).normalize();
      let velocity = new THREE.Vector3();

      function searchStep() {
        if (!autoAimState.running || autoAimState.iterations >= autoAimState.maxIterations) {
          autoAimState.running = false;
          autoAimBtn.style.display = 'inline-block';
          autoAimCancelBtn.style.display = 'none';
          if (autoAimState.best.dist === Infinity) {
            autoAimInfo.textContent = 'No solution found.';
          } else {
            const distKm = Math.sqrt(autoAimState.best.dist) * SCALE;
            autoAimInfo.textContent = `Best solution found: ${distKm.toExponential(2)} km`;
          }
          return;
        }

        const currentDist = calculateTrajectory(currentVec).distanceSq;
        if (currentDist < autoAimState.best.dist) {
          autoAimState.best.dist = currentDist;
          autoAimState.best.vec.copy(currentVec);
          payloadState.vecX = autoAimState.best.vec.x;
          payloadState.vecY = autoAimState.best.vec.y;
          payloadState.vecZ = autoAimState.best.vec.z;
          preview.dirty = true;
          const distKm = Math.sqrt(autoAimState.best.dist) * SCALE;
          autoAimInfo.textContent = `Best solution so far: ${distKm.toExponential(2)} km`;
        }

        // Calculate gradient
        const grad = new THREE.Vector3();
        const xVec = currentVec.clone();
        xVec.x += epsilon;
        const xDist = calculateTrajectory(xVec).distanceSq;
        grad.x = (xDist - currentDist) / epsilon;

        const yVec = currentVec.clone();
        yVec.y += epsilon;
        const yDist = calculateTrajectory(yVec).distanceSq;
        grad.y = (yDist - currentDist) / epsilon;

        const zVec = currentVec.clone();
        zVec.z += epsilon;
        const zDist = calculateTrajectory(zVec).distanceSq;
        grad.z = (zDist - currentDist) / epsilon;

        // Update velocity with momentum
        velocity.multiplyScalar(momentum).add(grad.multiplyScalar(-learningRate));

        // Update vector
        currentVec.add(velocity).normalize();

        autoAimState.iterations++;
        requestAnimationFrame(searchStep);
      }
      searchStep();
    };
    const autoAimInfo = document.createElement('div');
    autoAimInfo.style.marginTop = '4px';
    autoAimInfo.style.color = '#66ccff';
    autoAimInfo.textContent = 'Select a target and click Auto-Aim.';

    autoAimRow.appendChild(autoAimLabel);
    autoAimRow.appendChild(autoAimSelect);
    autoAimRow.appendChild(autoAimBtn);
    const autoAimCancelBtn = document.createElement('button');
    autoAimCancelBtn.textContent = 'Cancel';
    autoAimCancelBtn.style.display = 'none';
    autoAimCancelBtn.onclick = () => {
      autoAimState.running = false;
    };
    autoAimRow.appendChild(autoAimCancelBtn);
    autoAimForm.appendChild(autoAimRow);
    autoAimForm.appendChild(autoAimInfo);

    // Time slider
    const speedWrap = document.createElement('div');
    const speedLabel = document.createElement('span'); speedLabel.textContent = 'Scale:';
    const speedValue = document.createElement('span'); speedValue.className = 'muted value';
    const speedInput = document.createElement('input'); speedInput.type = 'range'; speedInput.min = '0'; speedInput.max = '9'; speedInput.step = '0.01'; speedInput.value = String(Math.log10(state.timeScaleMultiplier));
    const speedNumber = document.createElement('input'); speedNumber.type = 'number'; speedNumber.min = '1'; speedNumber.max = '1000000000'; speedNumber.step = '1'; speedNumber.value = String(state.timeScaleMultiplier); speedNumber.style.width = '90px';
    const speedGroup = document.createElement('div'); speedGroup.className = 'ctrl-group';
    speedGroup.appendChild(speedLabel); speedGroup.appendChild(speedInput); speedGroup.appendChild(speedNumber); speedGroup.appendChild(speedValue);
    speedWrap.appendChild(speedGroup);

    // Focus selector
    const focusSelect = document.createElement('select');
    for (const name of ['TARS', 'Sun', 'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']) {
      const opt = document.createElement('option'); opt.value = name; opt.textContent = name; if (name === state.focus) opt.selected = true; focusSelect.appendChild(opt);
    }

    // Thrust controls
    const thrustWrap = document.createElement('div');
    const thrustLabel = document.createElement('span'); thrustLabel.textContent = 'Thrust:';
    const mkBtn = (txt) => { const b = document.createElement('button'); b.textContent = txt; return b; };
    const btnProg = mkBtn('Prograde');
    const btnRetro = mkBtn('Retrograde');
    const btnRadOut = mkBtn('Radial Out');
    const btnRadIn = mkBtn('Radial In');
    const btnNormUp = mkBtn('Normal +');
    const btnNormDn = mkBtn('Normal -');
    const btnResetTars = mkBtn('Reset TARS');
    thrustWrap.appendChild(thrustLabel);
    thrustWrap.appendChild(btnProg); thrustWrap.appendChild(btnRetro);
    thrustWrap.appendChild(btnRadOut); thrustWrap.appendChild(btnRadIn);
    thrustWrap.appendChild(btnNormUp); thrustWrap.appendChild(btnNormDn);
    thrustWrap.appendChild(btnResetTars);

    // Assemble controls
    const row1 = document.createElement('div'); row1.className = 'row';
    row1.appendChild(btnStart); row1.appendChild(btnPause); row1.appendChild(btnStop); row1.appendChild(btnFollow); row1.appendChild(btnResetView);
    const row2 = document.createElement('div'); row2.className = 'row';
    row2.appendChild(btnFaster); row2.appendChild(btnSlower); row2.appendChild(btnSpin); row2.appendChild(focusSelect);
    const row3 = document.createElement('div'); row3.className = 'row';
    row3.appendChild(btnOrbits); row3.appendChild(btnStars); row3.appendChild(btnLabels); row3.appendChild(btnTrails); row3.appendChild(btnWells);
    btnBar.appendChild(row1);
    btnBar.appendChild(row2);
    btnBar.appendChild(row3);
    btnBar.appendChild(speedWrap);
    btnBar.appendChild(thrustWrap);
    panelControls.appendChild(btnBar);

    // Physics panel UI
    const physForm = document.createElement('div'); physForm.className = 'btnbar';
    function makeField(label, key, step, min, max) {
      const row = document.createElement('div'); row.className = 'row';
      const lbl = document.createElement('label'); lbl.textContent = label;
      const input = document.createElement('input'); input.type = 'number'; input.step = String(step); if (min != null) input.min = String(min); if (max != null) input.max = String(max);
      input.value = String(physics[key]); input.style.width = '120px';
      input.onchange = () => { const v = parseFloat(input.value); if (!Number.isFinite(v)) return; physics[key] = v; };
      row.appendChild(lbl); row.appendChild(input);
      return row;
    }
    physForm.appendChild(makeField('muSun (AU^3/yr^2)', 'muSun', 0.001, 0.0001));
    physForm.appendChild(makeField('maxDt (yr)', 'maxDt', 0.0001, 0.00001));
    physForm.appendChild(makeField('spinDecay', 'spinDecay', 0.001, 0));

    physForm.appendChild(makeField('Sail Area (m^2)', 'sailArea', 100, 0));
    physForm.appendChild(makeField('Sail Lever Arm (m)', 'sailLeverArm', 1, 0));

    physForm.appendChild(makeField('Payload Mass (kg)', 'payloadMass', 100, 0));
    {
      const row = document.createElement('div'); row.className = 'row';
      const lbl = document.createElement('label'); lbl.textContent = 'Tensile Strength (GPa)';
      const input = document.createElement('input'); input.type = 'number';
      input.step = '0.1';
      input.min = '0';
      input.value = String(physics.tensileStrengthPa / 1e9);
      input.style.width = '120px';
      input.onchange = () => {
        const gpa = parseFloat(input.value);
        if (Number.isFinite(gpa)) {
          physics.tensileStrengthPa = gpa * 1e9;
        }
      };
      row.appendChild(lbl);
      row.appendChild(input);
      physForm.appendChild(row);
    }
    physForm.appendChild(makeField('Tether Cross-sectional Area (m^2)', 'tetherCrossSectionalArea', 0.001, 0));
    physForm.appendChild(makeField('Tether Mass (kg)', 'tetherMass', 10, 0));
    physForm.appendChild(makeField('Reflectivity (White Sail)', 'sailReflectivityWhite', 0.01, 0, 1));
    physForm.appendChild(makeField('Reflectivity (Black Sail)', 'sailReflectivityBlack', 0.01, 0, 1));
    // N-body toggle
    const nBodyRow = document.createElement('div'); nBodyRow.className = 'row';
    const nBodyLbl = document.createElement('label'); nBodyLbl.textContent = 'N-body (planets attract craft/payloads)';
    const nBodyChk = document.createElement('input'); nBodyChk.type = 'checkbox'; nBodyChk.checked = physics.nBodyAttractors;
    nBodyChk.onchange = ()=> { physics.nBodyAttractors = nBodyChk.checked; };
    nBodyRow.appendChild(nBodyLbl); nBodyRow.appendChild(nBodyChk);
    physForm.appendChild(nBodyRow);
    // No additional Δv reserves controls: only payload exit velocity is tracked
    panelPhysics.appendChild(physForm);

    // ---------- Graphics panel UI ----------
    const gfxForm = document.createElement('div'); gfxForm.className = 'btnbar';
    function makeGfxSlider(label, min, max, step, initial, onChange) {
      const row = document.createElement('div'); row.className = 'row';
      const lbl = document.createElement('label'); lbl.textContent = label;
      const rng = document.createElement('input'); rng.type = 'range'; rng.min=String(min); rng.max=String(max); rng.step=String(step); rng.value=String(initial);
      const val = document.createElement('span'); val.className='value muted'; val.textContent = String(initial);
      rng.oninput = ()=>{ val.textContent = rng.value; onChange(parseFloat(rng.value)); };
      row.appendChild(lbl); row.appendChild(rng); row.appendChild(val);
      return row;
    }
    // Sun light intensity
    gfxForm.appendChild(makeGfxSlider('Sun light', 0, 50, 0.5, sunLight.intensity, (v)=>{ sunLight.intensity = v; }));
    // Ambient intensity
    gfxForm.appendChild(makeGfxSlider('Ambient', 0, 2, 0.05, ambient.intensity, (v)=>{ ambient.intensity = v; }));
    // Star size
    gfxForm.appendChild(makeGfxSlider('Star size', 0.5, 6, 0.1, (starfield.material.size||3), (v)=>{ if (starfield.material) { starfield.material.size = v; starfield.material.needsUpdate = true; } }));
    // Orbit guide opacity
    const initialOrbitOpacity = (orbitGuides[0] && orbitGuides[0].material && orbitGuides[0].material.opacity) || 0.06;
    gfxForm.appendChild(makeGfxSlider('Orbit opacity', 0, 1, 0.02, initialOrbitOpacity, (v)=>{ for (const l of orbitGuides) { if (l.material && l.material.transparent) l.material.opacity = v; } for (const w of gravityWells) { if (w.material && w.material.transparent) w.material.opacity = v; } }));

    // Background color
    const bgRow = document.createElement('div'); bgRow.className='row';
    const bgLbl = document.createElement('label'); bgLbl.textContent = 'Background';
    const bgInput = document.createElement('input'); bgInput.type='color'; bgInput.value='#000000';
    bgInput.onchange = ()=>{ const c = new THREE.Color(bgInput.value); scene.background = c; };
    bgRow.appendChild(bgLbl); bgRow.appendChild(bgInput);
    gfxForm.appendChild(bgRow);
    panelGraphics.appendChild(gfxForm);

    // ---------- True scale sizes (1:1 proportions) ----------
    const KM_PER_AU = 149597870.7;
    const planetRadiusKm = {
      Sun: 695700,
      Mercury: 2439.7,
      Venus: 6051.8,
      Earth: 6371.0,
      Mars: 3389.5,
      Jupiter: 69911,
      Saturn: 58232,
      Uranus: 25362,
      Neptune: 24622
    };
    
    function desiredRenderRadiusUnits(name) {
      const km = planetRadiusKm[name];
      if (!km) return null;
      const rAU = km / KM_PER_AU;
      return rAU * SCALE;
    }
    function applyTrueScaleSizes(enabled) {
      // Sun
      const sunBase = sun.userData.baseRenderRadius || 10;
      const sunDesired = desiredRenderRadiusUnits('Sun');
      const sunScale = enabled && sunDesired ? (sunDesired / sunBase) : 1;
      sun.scale.setScalar(sunScale);
      // Planets
      for (const p of planets) {
        const base = p.mesh.userData.baseRenderRadius || 1;
        const want = desiredRenderRadiusUnits(p.name);
        const s = enabled && want ? (want / base) : 1;
        p.mesh.scale.setScalar(Math.max(s, 1e-3));
        // keep labels above surface
        if (p.label) {
          const labelHeight = Math.max(1.8, (base * s) + 1.0);
          p.label.position.set(0, labelHeight, 0);
        }
      }
    }
    const trueScaleRow = document.createElement('div'); trueScaleRow.className = 'row';
    const trueScaleLbl = document.createElement('label'); trueScaleLbl.textContent = 'True scale sizes (proportional)';
    const trueScaleChk = document.createElement('input'); trueScaleChk.type = 'checkbox'; trueScaleChk.checked = true;
    trueScaleChk.onchange = ()=> applyTrueScaleSizes(trueScaleChk.checked);
    trueScaleRow.appendChild(trueScaleLbl); trueScaleRow.appendChild(trueScaleChk);
    gfxForm.appendChild(trueScaleRow);
    // apply once on load
    applyTrueScaleSizes(trueScaleChk.checked);

    // ---------- Launch Payload panel (combined) ----------
    const payloadForm = document.createElement('div'); payloadForm.className = 'btnbar';
    const payloadState = {
      tipScaleMSPerRad: 10, // m/s per rad/s
      dvMag: 100,       // m/s
      vecX: 1, vecY: 0, vecZ: 0 // vector components in world frame (normalized when used)
    };
    function rowWrap(...nodes) { const r = document.createElement('div'); r.className = 'row'; nodes.forEach(n => r.appendChild(n)); return r; }
    
    
    // Custom vector inputs (visible in vector mode)
    const vecX = document.createElement('input'); vecX.type='number'; vecX.step='0.1'; vecX.value=String(payloadState.vecX);
    const vecY = document.createElement('input'); vecY.type='number'; vecY.step='0.1'; vecY.value=String(payloadState.vecY);
    const vecZ = document.createElement('input'); vecZ.type='number'; vecZ.step='0.1'; vecZ.value=String(payloadState.vecZ);
    [vecX, vecY, vecZ].forEach((el, idx)=>{ el.style.width='60px'; el.oninput=()=>{ const v=parseFloat(el.value)||0; if(idx===0) payloadState.vecX=v; if(idx===1) payloadState.vecY=v; if(idx===2) payloadState.vecZ=v; preview.dirty=true; }; });
    const vecRow = rowWrap(document.createTextNode('Vector (x,y,z):'), vecX, vecY, vecZ);
    function refreshVectorRowVisibility(){ vecRow.style.display = ''; }
    refreshVectorRowVisibility();
    const btnLaunch = document.createElement('button');
    btnLaunch.textContent = 'Launch';
    btnLaunch.style.backgroundColor = '#ef4444';
    btnLaunch.style.fontSize = '16px';
    btnLaunch.style.padding = '8px 16px';
    const btnClear = document.createElement('button'); btnClear.textContent='Clear payloads';
    payloadForm.appendChild(rowWrap(btnLaunch, btnClear));
        // Targeting subset
        const targetForm = document.createElement('div'); targetForm.className = 'btnbar';
        const targetState = { mode: 'none', body: 'None', point: null };
    
    
        const previewToggle = document.createElement('button'); previewToggle.textContent = 'Preview: Off';
        previewToggle.onclick = ()=>{ preview.enabled = !preview.enabled; preview.payload.line.visible = preview.enabled; preview.dirty = true; previewToggle.textContent = `Preview: ${preview.enabled ? 'On' : 'Off'}`; };
        const horizonLabel = document.createElement('label'); horizonLabel.textContent = 'Horizon (days)';
        const horizonInput = document.createElement('input'); horizonInput.type='number'; horizonInput.step='1'; horizonInput.min='1'; horizonInput.value = String(Math.round(preview.horizonYears * 365.25));
        horizonInput.onchange = ()=>{ const d = Math.max(1, parseFloat(horizonInput.value)||30); preview.horizonYears = d / 365.25; preview.dirty = true; };
        const stepsLabel = document.createElement('label'); stepsLabel.textContent = 'Steps';
        const stepsInput = document.createElement('input'); stepsInput.type='number'; stepsInput.step='10'; stepsInput.min='10'; stepsInput.max='2000'; stepsInput.value = String(preview.steps);
        stepsInput.onchange = ()=>{ const s = Math.min(2000, Math.max(10, parseInt(stepsInput.value)||300)); preview.steps = s; preview.dirty = true; };
    
        targetForm.appendChild(rowWrap(previewToggle, horizonLabel, horizonInput, stepsLabel, stepsInput));
        panelLaunch.appendChild(payloadForm);
        panelLaunch.appendChild(targetForm);
        // Aim helpers UI (for vector mode)
        const aimForm = document.createElement('div'); aimForm.className = 'btnbar';
    
        const aimRow2 = document.createElement('div'); aimRow2.className = 'row';
        const azLbl = document.createElement('label'); azLbl.textContent='Azimuth (°)'
        const elLbl = document.createElement('label'); elLbl.textContent='Elevation (°)'
        const azInput = document.createElement('input'); azInput.type='number'; azInput.step='0.1'; azInput.min='-180'; azInput.max='180'; azInput.style.width='80px';
        const elInput = document.createElement('input'); elInput.type='number'; elInput.step='0.1'; elInput.min='-89.9'; elInput.max='89.9'; elInput.style.width='80px';
        aimRow2.appendChild(azLbl); aimRow2.appendChild(azInput);
        aimRow2.appendChild(elLbl); aimRow2.appendChild(elInput);
        // Snap buttons
        const aimRow3 = document.createElement('div'); aimRow3.className='row';
        aimRow3.appendChild(vecRow);    aimForm.appendChild(aimRow2); aimForm.appendChild(aimRow3);
        panelLaunch.appendChild(autoAimForm);
    panelLaunch.appendChild(aimForm);

    // -------- Aim Ball (2D UI sphere to pick 3D direction) --------
    const aimBallWrap = document.createElement('div'); aimBallWrap.className='btnbar';
    const aimBallRow = document.createElement('div'); aimBallRow.className='row';
    const aimBallCanvas = document.createElement('canvas'); aimBallCanvas.width = 300; aimBallCanvas.height = 300; aimBallCanvas.style.cursor='crosshair'; aimBallCanvas.title = 'Drag to aim (2D sphere)';
    aimBallRow.appendChild(aimBallCanvas);

    const legendDiv = document.createElement('div');
    legendDiv.style.display = 'flex';
    legendDiv.style.flexDirection = 'column';
    legendDiv.style.marginLeft = '10px';
    legendDiv.style.fontSize = '12px';

    function createLegendItem(color, text) {
        const item = document.createElement('div');
        item.style.display = 'flex';
        item.style.alignItems = 'center';
        item.style.marginBottom = '5px';
        const colorBox = document.createElement('div');
        colorBox.style.width = '10px';
        colorBox.style.height = '10px';
        colorBox.style.backgroundColor = color;
        colorBox.style.marginRight = '5px';
        const label = document.createElement('span');
        label.textContent = text;
        item.appendChild(colorBox);
        item.appendChild(label);
        return item;
    }

    legendDiv.appendChild(createLegendItem('#22c55e', 'Aim (front)'));
    legendDiv.appendChild(createLegendItem('#ef4444', 'Aim (back)'));
    legendDiv.appendChild(createLegendItem('blue', 'Prograde'));
    legendDiv.appendChild(createLegendItem('orange', 'Retrograde'));

    aimBallRow.appendChild(legendDiv);

    aimBallWrap.appendChild(aimBallRow);
    panelLaunch.appendChild(aimBallWrap);

    // ---------- Targets feature ----------
    const targetsState = {
      asteroidMass: 100000, // kg
      asteroidRadius: 50, // m
      interceptVelocity: 10000, // m/s
      impactPulse: 0
    };

    function calculateImpactPulse() {
      targetsState.impactPulse = targetsState.asteroidMass * targetsState.interceptVelocity;
      const impactPulseDisplay = document.getElementById('impact-pulse-display');
      if (impactPulseDisplay) {
        impactPulseDisplay.textContent = `Impact Pulse: ${targetsState.impactPulse.toExponential(2)} Ns`;
      }
    }

    function spawnAsteroid() {
      const earth = planets.find(p => p.name === 'Earth');
      if (!earth) {
        console.error("Earth not found!");
        return;
      }

      const id = `asteroid_${nextObjectId++}`;
      const color = 0xff8844;
      const radiusKm = targetsState.asteroidRadius / 1000;
      const geom = new THREE.SphereGeometry(radiusKm, 20, 20);
      const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.1, roughness: 0.9 });
      const mesh = new THREE.Mesh(geom, mat);
      scene.add(mesh);
      const label = createLabelSprite('Asteroid');
      label.position.set(0, radiusKm + 1, 0);
      label.visible = state.showLabels;
      mesh.add(label);

      // Position the asteroid at a random position in the outer solar system
      const radiusAU = 30 + Math.random() * 20; // 30-50 AU
      const angle = Math.random() * 2 * Math.PI;
      const asteroidPosition = new THREE.Vector3(
        radiusAU * Math.cos(angle),
        (Math.random() - 0.5) * 5, // small random inclination
        radiusAU * Math.sin(angle)
      );

      // Velocity vector towards the inner solar system, with some randomness
      const velocity = new THREE.Vector3(
        -asteroidPosition.x,
        -asteroidPosition.y,
        -asteroidPosition.z
      ).normalize();
      // Add some random perturbation to the velocity
      velocity.x += (Math.random() - 0.5) * 0.5;
      velocity.y += (Math.random() - 0.5) * 0.1;
      velocity.z += (Math.random() - 0.5) * 0.5;
      velocity.normalize();
      velocity.multiplyScalar(mpsToAUPerYr(targetsState.interceptVelocity));


      const asteroid = {
        id,
        position: asteroidPosition,
        velocity: velocity,
        mesh,
        label,
        color,
        trail: createTrail(600, color)
      };
      scene.add(asteroid.trail.line);
      asteroid.trail.line.visible = state.showTrails;
      if (asteroid.trail.headLine) {
        scene.add(asteroid.trail.headLine);
        asteroid.trail.headLine.visible = state.showTrails;
      }
      simObjects.asteroids.push(asteroid);
      calculateImpactPulse();
      return id;
    }
    
    function updateAsteroids(dtYears) {
      for (const a of simObjects.asteroids) {
        integrateSunGravityVecVerlet(a.position, a.velocity, dtYears);
      }
    }

    const targetsForm = document.createElement('div');
    targetsForm.className = 'btnbar';

    function makeTargetField(label, key, step, min, max) {
      const row = document.createElement('div');
      row.className = 'row';
      const lbl = document.createElement('label');
      lbl.textContent = label;
      const input = document.createElement('input');
      input.type = 'number';
      input.step = String(step);
      if (min != null) input.min = String(min);
      if (max != null) input.max = String(max);
      input.value = String(targetsState[key]);
      input.style.width = '120px';
      input.onchange = () => {
        const v = parseFloat(input.value);
        if (!Number.isFinite(v)) return;
        targetsState[key] = v;
        calculateImpactPulse();
      };
      row.appendChild(lbl);
      row.appendChild(input);
      return row;
    }

    targetsForm.appendChild(makeTargetField('Asteroid Mass (kg)', 'asteroidMass', 1000, 0));
    targetsForm.appendChild(makeTargetField('Asteroid Radius (m)', 'asteroidRadius', 10, 0));
    targetsForm.appendChild(makeTargetField('Intercept Velocity (m/s)', 'interceptVelocity', 100, 0));

    const spawnBtn = document.createElement('button');
    spawnBtn.textContent = 'Spawn Asteroid';
    spawnBtn.onclick = spawnAsteroid;
    targetsForm.appendChild(spawnBtn);

    const impactPulseDisplay = document.createElement('div');
    impactPulseDisplay.id = 'impact-pulse-display';
    impactPulseDisplay.style.marginTop = '6px';
    impactPulseDisplay.style.color = '#ff6666';
    targetsForm.appendChild(impactPulseDisplay);
    
    panelTargets.appendChild(targetsForm);
    calculateImpactPulse();

    function updateAimBallVisibility() { aimBallWrap.style.display = ''; }
    updateAimBallVisibility();
    
    drawAimBall();

    const aimBallState = {
        pos: { u: 0, v: 0 },
        vel: { u: 0, v: 0 },
        accumulatedVel: { u: 0, v: 0 },
        dragging: false,
        lastPointer: { x: 0, y: 0, time: 0 },
        friction: 0.95,
        springK: 200.0, // Spring constant for pulling towards the cursor
        damping: 25.0,   // Damping factor to prevent oscillation
        targetPos: { u: 0, v: 0 },
    };

    function updateAimBallFromWorldDir() {
        const dir = new THREE.Vector3(payloadState.vecX, payloadState.vecY, payloadState.vecZ).normalize();
        const { right, up } = basisForAim();
        aimBallState.pos.u = dir.dot(right);
        aimBallState.pos.v = dir.dot(up);
    }

    function updateAimBallInertia(dt) {
        if (aimBallState.dragging) {
            // Spring-like motion towards the cursor
            const targetU = aimBallState.targetPos ? aimBallState.targetPos.u : 0;
            const targetV = aimBallState.targetPos ? aimBallState.targetPos.v : 0;

            const F_spring_u = (targetU - aimBallState.pos.u) * aimBallState.springK;
            const F_spring_v = (targetV - aimBallState.pos.v) * aimBallState.springK;

            const F_damp_u = -aimBallState.vel.u * aimBallState.damping;
            const F_damp_v = -aimBallState.vel.v * aimBallState.damping;

            const F_u = F_spring_u + F_damp_u;
            const F_v = F_spring_v + F_damp_v;

            aimBallState.vel.u += F_u * dt;
            aimBallState.vel.v += F_v * dt;
        } else {
            // Inertial motion with friction
            const speed = Math.sqrt(aimBallState.vel.u * aimBallState.vel.u + aimBallState.vel.v * aimBallState.vel.v);
            if (speed < 0.001) {
                aimBallState.vel = { u: 0, v: 0 };
            }
            const friction = Math.pow(aimBallState.friction, dt * 60);
            aimBallState.vel.u *= friction;
            aimBallState.vel.v *= friction;
        }

        if (aimBallState.dragging || Math.abs(aimBallState.vel.u) > 1e-5 || Math.abs(aimBallState.vel.v) > 1e-5) {
            aimBallState.pos.u += aimBallState.vel.u * dt;
            aimBallState.pos.v += aimBallState.vel.v * dt;
            setVectorFromBallPoint(aimBallState.pos.u, aimBallState.pos.v, true);
        }
    }

    function basisForAim() {
      // Camera-oriented basis so the aim ball center aligns with camera center
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion).normalize();
      let right = new THREE.Vector3().crossVectors(forward, up);
      if (right.lengthSq() < 1e-12) right = new THREE.Vector3(1, 0, 0);
      right.normalize();
      return { right, up, forward };
    }

    function drawAimBall() {
      if (!aimBallCanvas || aimBallWrap.style.display === 'none') return;
      const ctx = aimBallCanvas.getContext('2d');
      const W = aimBallCanvas.width, H = aimBallCanvas.height; const cx = W/2, cy = H/2, R = Math.min(W,H)*0.48;
      ctx.clearRect(0,0,W,H);
      // Outer circle
      ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.strokeStyle = '#6b7280'; ctx.lineWidth = 1; ctx.stroke();
      // Light shading
      const grd = ctx.createRadialGradient(cx-0.3*R, cy-0.3*R, 0, cx, cy, R);
      grd.addColorStop(0, '#334155'); grd.addColorStop(1, '#0f172a');
      ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(cx, cy, R-1, 0, Math.PI*2); ctx.fill();
      // Current vector projected
      const dir = new THREE.Vector3(payloadState.vecX, payloadState.vecY, payloadState.vecZ);
      if (dir.lengthSq() < 1e-12) dir.set(1,0,0); dir.normalize();
      const { right, up, forward } = basisForAim();
      const u = dir.dot(right), v = dir.dot(up), w = dir.dot(forward);
      const r2 = u*u + v*v;
      const inside = r2 <= 1 + 1e-6;
      const px = cx + (u * R);
      const py = cy - (v * R);
      // Crosshair
      ctx.strokeStyle = '#94a3b8'; ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.moveTo(cx-R, cy); ctx.lineTo(cx+R, cy); ctx.moveTo(cx, cy-R); ctx.lineTo(cx, cy+R); ctx.stroke(); ctx.globalAlpha=1;
      // Dot
      ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2);
      ctx.fillStyle = (w >= 0) ? '#22c55e' : '#ef4444';
      ctx.fill(); ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.stroke();

      // Prograde vector
      const { prograde } = getOrthoBasis();
      const prograde_u = prograde.dot(right);
      const prograde_v = prograde.dot(up);
      const prograde_w = prograde.dot(forward);

      if (prograde_w >= 0) { // Only draw if it's on the visible hemisphere
          const prograde_px = cx + (prograde_u * R);
          const prograde_py = cy - (prograde_v * R);

          ctx.beginPath();
          ctx.arc(prograde_px, prograde_py, 4, 0, Math.PI*2);
          ctx.fillStyle = 'blue';
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1;
          ctx.stroke();
      }

      // Retrograde vector
      const retrograde = prograde.clone().negate();
      const retrograde_u = retrograde.dot(right);
      const retrograde_v = retrograde.dot(up);
      const retrograde_w = retrograde.dot(forward);

      if (retrograde_w >= 0) { // Only draw if it's on the visible hemisphere
          const retrograde_px = cx + (retrograde_u * R);
          const retrograde_py = cy - (retrograde_v * R);

          ctx.beginPath();
          ctx.arc(retrograde_px, retrograde_py, 4, 0, Math.PI*2);
          ctx.fillStyle = 'orange';
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1;
          ctx.stroke();
      }
    }

    function setVectorFromBallPoint(u, v, allowBack) {
      const r2 = u*u + v*v;
      let w = 0;
      if (r2 <= 1) {
        w = Math.sqrt(Math.max(0, 1 - r2));
      } else {
        const s = 1/Math.sqrt(r2); u *= s; v *= s; // clamp onto circle
      }
      if (allowBack) {
        // Determine hemisphere by current vector sign along forward
        const { forward } = basisForAim();
        const curr = new THREE.Vector3(payloadState.vecX, payloadState.vecY, payloadState.vecZ).normalize();
        const sign = Math.sign(curr.dot(forward)) || 1;
        w *= sign;
      }
      const { right, up, forward } = basisForAim();
      const worldDir = new THREE.Vector3().addScaledVector(right, u).addScaledVector(up, v).addScaledVector(forward, w).normalize();
      setVectorFromDir(worldDir);
      updateAzElInputs();
    }

    (function initAimBallEvents(){
      aimBallCanvas.addEventListener('pointerdown', (e)=>{
        aimBallState.dragging = true;
        aimBallState.vel = { u: 0, v: 0 };
        aimBallState.accumulatedVel = { u: 0, v: 0 };
        aimBallCanvas.setPointerCapture?.(e.pointerId);
        const rect = aimBallCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left); const y = (e.clientY - rect.top);
        const cx = rect.width/2, cy = rect.height/2, R = Math.min(rect.width, rect.height)*0.48;
        const u = (x - cx)/R, v = -(y - cy)/R;
        
        aimBallState.targetPos = { u, v };
        aimBallState.lastPointer = { x, y, time: performance.now() };

        // No direct setting of position, let the spring do the work
      });
      aimBallCanvas.addEventListener('pointermove', (e)=>{
        if (!aimBallState.dragging) return;
        const rect = aimBallCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left); const y = (e.clientY - rect.top);
        const cx = rect.width/2, cy = rect.height/2, R = Math.min(rect.width, rect.height)*0.48;
        const u = (x - cx)/R, v = -(y - cy)/R;

        aimBallState.targetPos = { u, v };

        const now = performance.now();
        const dt = (now - aimBallState.lastPointer.time) / 1000;
        if (dt > 0.001) {
            const new_u_vel = (u - aimBallState.pos.u) / dt;
            const new_v_vel = (v - aimBallState.pos.v) / dt;
            // Accumulate velocity with some smoothing
            aimBallState.accumulatedVel.u = aimBallState.accumulatedVel.u * 0.5 + new_u_vel * 0.5;
            aimBallState.accumulatedVel.v = aimBallState.accumulatedVel.v * 0.5 + new_v_vel * 0.5;
        }
        
        aimBallState.lastPointer = { x, y, time: now };
      });
      aimBallCanvas.addEventListener('pointerup', (e)=>{ 
        aimBallState.dragging = false; 
        aimBallCanvas.releasePointerCapture?.(e.pointerId);
        aimBallState.vel = { u: 0, v: 0 };
      });
      aimBallCanvas.addEventListener('pointerleave', ()=>{ 
        if (aimBallState.dragging) {
            aimBallState.dragging = false;
            aimBallState.vel = { u: 0, v: 0 };
        }
      });
    })();;

    

    // -------- Movable sight gizmo (Shift+Drag to aim) --------
    const sightDrag = { active: false, lastX: 0, lastY: 0 };
    const aimSense = 0.005;
    function setVectorFromDir(dir) {
      const d = dir.clone(); if (d.lengthSq() < 1e-12) d.set(1,0,0); d.normalize();
      payloadState.vecX = d.x; payloadState.vecY = d.y; payloadState.vecZ = d.z; preview.dirty = true;
      // reflect in inputs
      try { vecX.value = String(payloadState.vecX.toFixed(6)); vecY.value = String(payloadState.vecY.toFixed(6)); vecZ.value = String(payloadState.vecZ.toFixed(6)); } catch {}
      drawAimBall();
    }
    function onPointerDownAim(e) {
      if (!(state.focus === 'TARS')) return;
      if (!e.shiftKey) return;
      sightDrag.active = true; sightDrag.lastX = e.clientX; sightDrag.lastY = e.clientY;
      try { renderer.domElement.setPointerCapture(e.pointerId); } catch {}
      controls.enabled = false;
      e.preventDefault();
    }
    function onPointerMoveAim(e) {
      if (!sightDrag.active) return;
      const dx = e.clientX - sightDrag.lastX;
      const dy = e.clientY - sightDrag.lastY;
      sightDrag.lastX = e.clientX;
      sightDrag.lastY = e.clientY;

      const curr = new THREE.Vector3(payloadState.vecX, payloadState.vecY, payloadState.vecZ).normalize();

      // Get camera's up vector
      const camUp = new THREE.Vector3(0,1,0).applyQuaternion(camera.quaternion).normalize();

      // Create a basis from the current aim direction
      const right = new THREE.Vector3().crossVectors(camUp, curr).normalize();
      const up = new THREE.Vector3().crossVectors(curr, right).normalize();

      // Rotate the aim direction
      curr.applyAxisAngle(up, -dx * aimSense);
      curr.applyAxisAngle(right, -dy * aimSense);

      setVectorFromDir(curr);
      e.preventDefault();
    }
    function onPointerUpAim(e) {
      if (!sightDrag.active) return;
      sightDrag.active = false;
      try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
      controls.enabled = true;
      e.preventDefault();
    }
    renderer.domElement.addEventListener('pointerdown', onPointerDownAim);
    renderer.domElement.addEventListener('pointermove', onPointerMoveAim);
    renderer.domElement.addEventListener('pointerup', onPointerUpAim);
    renderer.domElement.addEventListener('pointerleave', onPointerUpAim);

    // Azimuth/elevation helpers operate in world frame (Y-up)
    function getAimDir() { return new THREE.Vector3(payloadState.vecX, payloadState.vecY, payloadState.vecZ).normalize(); }
    function setAimFromAzEl(azDeg, elDeg) {
      const az = azDeg * Math.PI/180, el = elDeg * Math.PI/180;
      // World-fixed basis
      const up = new THREE.Vector3(0,1,0);
      const forward = new THREE.Vector3(0,0,1);
      const right = new THREE.Vector3(1,0,0);

      // Build orientation: rotate around up by az, then around right by el
      const dir = forward.clone().applyAxisAngle(up, az).applyAxisAngle(right, el).normalize();
      setVectorFromDir(dir);
    }
    function updateAzElInputs() {
      const dir = getAimDir();
      // World-fixed basis
      const up = new THREE.Vector3(0,1,0);
      const forward = new THREE.Vector3(0,0,1);
      const right = new THREE.Vector3(1,0,0);

      // Compute azimuth/elevation from world basis
      const x = dir.dot(right);
      const y = dir.dot(up);
      const z = dir.dot(forward);
      const el = Math.asin(Math.max(-1, Math.min(1, y)));
      const az = Math.atan2(x, z);
      azInput.value = String((az*180/Math.PI).toFixed(0));
      elInput.value = String((el*180/Math.PI).toFixed(0));
    }
    azInput.onchange = ()=> setAimFromAzEl(parseFloat(azInput.value)||0, parseFloat(elInput.value)||0);
    elInput.onchange = ()=> setAimFromAzEl(parseFloat(azInput.value)||0, parseFloat(elInput.value)||0);
    updateAzElInputs();

    function mpsToAUPerYr(mps) { return mps * (1/149597870700) * (365.25*24*3600); }
    function auPerYrToMps(auPerYr) { return auPerYr * 149597870700 / (365.25*24*3600); }
    function computeSpinDvAUPerYr() {
      // tip speed [m/s] = spin [rad/s] * (tipScaleMSPerRad)
      const dv_mps = Math.max(0, tars.spin) * payloadState.tipScaleMSPerRad;
      return mpsToAUPerYr(dv_mps);
    }
    function getTipTangentDir() {
      const { prograde } = getOrthoBasis();
      const up = new THREE.Vector3(0, 1, 0);
      const right = new THREE.Vector3().crossVectors(up, prograde).normalize();
      // Tangent aligned with spin phase by rotating prograde around up
      return prograde.clone().applyAxisAngle(up, tars.spinPhase).normalize();
    }

    function releasePayloadNow(direction) {
      // Ejection direction and magnitude determine payload exit velocity relative to TARS.
      const r = physics.sailLeverArm; // Use sailLeverArm as the release radius
      const w = tars.spin;
      const v_mps = r * w;
      let dvAUPerYr = mpsToAUPerYr(v_mps);

      let dir = direction;
      if (!dir) {
        dir = new THREE.Vector3(payloadState.vecX, payloadState.vecY, payloadState.vecZ);
      }
      if (dir.lengthSq() < 1e-12) dir.set(1,0,0);
      dir.normalize();
      // Track the single Δv quantity: payload exit speed in m/s
      tars.lastExitVelocityMps = v_mps;
      const init = {
        position: tars.position.clone(),
        velocity: tars.velocity.clone().add(new THREE.Vector3().copy(dir).multiplyScalar(dvAUPerYr)),
        color: 0x66ff88
      };
      const payloadId = spawnPayload(init);
      const payload = simObjects.payloads.find(p => p.id === payloadId);
      if (payload) {
        nameToBody[payload.id] = payload.mesh;
        const opt = document.createElement('option');
        opt.value = payload.id;
        opt.textContent = payload.id;
        focusSelect.appendChild(opt);
        focusSelect.value = payload.id;
        state.focus = payload.id;
        state.followTARS = true;
        const focusObj = nameToBody[state.focus];
        if (state.followTARS && focusObj) {
          const targetPosition = new THREE.Vector3();
          focusObj.getWorldPosition(targetPosition);
          state.prevFollowTarget = targetPosition.clone();
          // Also move the camera to an initial position relative to the payload
          const offset = new THREE.Vector3(0, 10, 20); // 10km up, 20km back
          camera.position.copy(targetPosition).add(offset);
        }
      }
    }
    btnLaunch.onclick = () => releasePayloadNow();
    btnClear.onclick = ()=>{
      [...simObjects.payloads.map(p=>p.id)].forEach(despawnById);
    };

    // ---------- Legacy targeting block removed (merged into Launch panel) ----------

    function setActiveTab(which) {
      const map = {
        controls: [tabControls, panelControls],
        physics: [tabPhysics, panelPhysics],
        graphics: [tabGraphics, panelGraphics],
        launch: [tabLaunch, panelLaunch],
        targets: [tabTargets, panelTargets]
      };
      for (const k of Object.keys(map)) {
        const [btn, panel] = map[k];
        btn.classList.toggle('active', k === which);
        panel.classList.toggle('active', k === which);
      }
    }
    tabControls.onclick = () => setActiveTab('controls');
    tabPhysics.onclick = () => setActiveTab('physics');
    tabLaunch.onclick = () => setActiveTab('launch');
    tabGraphics.onclick = () => setActiveTab('graphics');
    tabTargets.onclick = () => setActiveTab('targets');

    function setMultiplier(x) {
      const clamped = Math.max(1, Math.min(1_000_000_000, Math.round(x)));
      state.timeScaleMultiplier = clamped;
      state.timeScaleYearsPerSec = clamped * REALTIME_YEARS_PER_SEC;
      speedInput.value = String(Math.log10(clamped)); // Store log value for slider
      speedNumber.value = String(clamped); // Store actual value for number input
      speedValue.textContent = `${clamped.toLocaleString()}x (${state.timeScaleYearsPerSec.toExponential(3)} y/s)`;
    }
    setMultiplier(state.timeScaleMultiplier);

    btnStart.onclick = () => { state.paused = false; };
    btnPause.onclick = () => { state.paused = true; };
    btnStop.onclick = () => { state.paused = true; setMultiplier(1); };
    btnFollow.onclick = () => {
      state.followTARS = !state.followTARS;
      const focusObj = nameToBody[state.focus];
      if (state.followTARS && focusObj) {
        const targetPosition = new THREE.Vector3();
        focusObj.getWorldPosition(targetPosition);
        state.prevFollowTarget = targetPosition.clone();
      } else {
        state.prevFollowTarget = null;
      }
    };
    btnFaster.onclick = () => { setMultiplier(state.timeScaleMultiplier * 1.6); };
    btnSlower.onclick = () => { setMultiplier(state.timeScaleMultiplier / 1.6); };
    btnSpin.onclick = () => {
      // Boost spin directly (no reserves)
      tars.spin += 0.1; // small bump
    };
    btnOrbits.onclick = () => {
      state.showOrbits = !state.showOrbits;
      for (const l of orbitGuides) l.visible = state.showOrbits;
    };
    btnStars.onclick = () => { state.showStarfield = !state.showStarfield; starfield.visible = state.showStarfield; };
    btnLabels.onclick = () => {
      state.showLabels = !state.showLabels;
      for (const label of allLabels) {
        label.visible = state.showLabels;
      }
    };
    btnTrails.onclick = () => {
      state.showTrails = !state.showTrails;
      tarsTrail.line.visible = state.showTrails;
      for (const pl of simObjects.payloads) if (pl.trail && pl.trail.line) pl.trail.line.visible = state.showTrails;
      for (const a of simObjects.asteroids) if (a.trail && a.trail.line) a.trail.line.visible = state.showTrails;
    };
    btnWells.onclick = () => {
      state.showGravityWells = !state.showGravityWells;
      for (const well of gravityWells) {
        well.visible = state.showGravityWells;
      }
    };
    btnResetView.onclick = () => frameFocus(true);
    speedInput.oninput = () => { setMultiplier(Math.pow(10, parseFloat(speedInput.value))); }; // Convert back to linear
    speedNumber.onchange = () => { setMultiplier(parseFloat(speedNumber.value) || 1); };
    focusSelect.onchange = () => {
      state.focus = focusSelect.value;
      frameFocus(true);
      const focusObj = nameToBody[state.focus];
      if (state.followTARS && focusObj) {
        state.followOffset = camera.position.clone().sub(focusObj.position);
        state.prevFollowTarget = focusObj.position.clone();
      }
    };
    
    const DV = 0.001; // AU/year per click
    // Keyboard shortcuts
    // Space: play/pause, +/-: faster/slower, o/s/l/t: toggles, f: follow, r: reset view, p: boost spin
    // Arrows: apply small thrusts (Up=prograde, Down=retrograde, Left=radial in, Right=radial out)
    window.addEventListener('keydown', (e) => {
      // Avoid interfering with typing in inputs
      const tag = (document.activeElement && document.activeElement.tagName) || '';
      if (tag === 'INPUT' || tag === 'TEXTAREA') return;
      const key = e.key;
      if (key === ' ') { e.preventDefault(); state.paused = !state.paused; return; }
      if (key === '+' || key === '=' || key === ']') { setMultiplier(state.timeScaleMultiplier * 1.6); return; }
      if (key === '-' || key === '_' || key === '[') { setMultiplier(state.timeScaleMultiplier / 1.6); return; }
      if (key === 'o' || key === 'O') { btnOrbits.click(); return; }
      if (key === 's' || key === 'S') { btnStars.click(); return; }
      if (key === 'l' || key === 'L') { btnLabels.click(); return; }
      if (key === 't' || key === 'T') { btnTrails.click(); return; }
      if (key === 'f' || key === 'F') { btnFollow.click(); return; }
      if (key === 'r' || key === 'R') { btnResetView.click(); return; }
      if (key === 'p' || key === 'P') { btnSpin.click(); return; }
      if (key === 'x' || key === 'X') { tars.spin += 20; return; }
      if (key === 'z' || key === 'Z') { tars.spin -= 20; return; }
      const DV_KEY = DV;
      if (key === 'ArrowUp') { e.preventDefault(); const { prograde } = getOrthoBasis(); tryApplyDv(prograde, DV_KEY); return; }
      if (key === 'ArrowDown') { e.preventDefault(); const { prograde } = getOrthoBasis(); tryApplyDv(prograde.multiplyScalar(-1), DV_KEY); return; }
      if (key === 'ArrowLeft') { e.preventDefault(); const { radial } = getOrthoBasis(); tryApplyDv(radial.multiplyScalar(-1), DV_KEY); return; }
      if (key === 'ArrowRight') { e.preventDefault(); const { radial } = getOrthoBasis(); tryApplyDv(radial, DV_KEY); return; }
    });

    function frameFocus(instant = false) {
      const obj = nameToBody[state.focus];
      if (!obj) return;
      const target = obj.position.clone();
      const lerpAlpha = instant ? 1.0 : 0.5;
      controls.target.lerp(target, lerpAlpha);
      // Set camera distance heuristically per body
      const distAU = (state.focus === 'Sun') ? 10 : (state.focus === 'TARS') ? 0.1 : 2.0;
      const toCam = new THREE.Vector3(0, SCALE * distAU * 0.6, SCALE * distAU);
      if (instant) {
        camera.position.copy(target.clone().add(toCam));
        camera.lookAt(target);
        state.followOffset = camera.position.clone().sub(target);
      }
    }

    // Initial camera framing and resize handling
    controls.target.set(0, 0, 0);
    camera.lookAt(controls.target);
    frameFocus(true);
    btnFollow.click();
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Labels via CanvasTexture sprites
    function createLabelSprite(text) {
      const cnv = document.createElement('canvas');
      const ctx = cnv.getContext('2d');
      const fs = 24; // smaller font
      const font = `bold ${fs}px sans-serif`;
      ctx.font = font;
      const w = Math.ceil(ctx.measureText(text).width) + 16;
      const h = fs + 16;
      cnv.width = w; cnv.height = h;

      ctx.font = font;
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';

      ctx.strokeStyle = 'rgba(0,0,0,0.7)';
      ctx.lineWidth = 4;
      ctx.strokeText(text, w/2, h/2);

      ctx.fillStyle = 'white';
      ctx.fillText(text, w/2, h/2);

      const tex = new THREE.CanvasTexture(cnv);
      tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
      const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false, transparent: true });
      const sprite = new THREE.Sprite(mat);
      sprite.userData.name = text;
      sprite.renderOrder = 9999;
      sprite.visible = state.showLabels; // Set initial visibility
      allLabels.push(sprite);
      return sprite;
    }
    for (const p of planets) {
      const label = createLabelSprite(p.name);
      label.position.set(0, Math.max(1.8, p.radiusRender + 1.0), 0);
      label.visible = state.showLabels;
      p.mesh.add(label);
      p.label = label;
    }
    
    // Label for TARS
    const tarsLabel = createLabelSprite('TARS');
    tarsLabel.position.set(0, 4.0, 0);
    tarsLabel.visible = state.showLabels;
    tars.mesh.add(tarsLabel);

    // ---------- Animation loop ----------
    // Basic on-screen error reporting to help diagnose blank page issues
    window.addEventListener('error', (e) => {
      const div = document.createElement('div');
      div.style.position = 'fixed'; div.style.left = '12px'; div.style.bottom = '12px'; div.style.zIndex = '9999';
      div.style.maxWidth = '50vw'; div.style.background = 'rgba(80,0,0,0.8)'; div.style.padding = '8px 10px'; div.style.border = '1px solid #a44'; div.style.borderRadius = '6px';
      div.style.fontSize = '12px'; div.style.whiteSpace = 'pre-wrap'; div.textContent = `Error: ${e.message}`;
      document.body.appendChild(div);
      console.error(e.error || e.message);
    });
    window.addEventListener('unhandledrejection', (e) => {
      const div = document.createElement('div');
      div.style.position = 'fixed'; div.style.left = '12px'; div.style.bottom = '12px'; div.style.zIndex = '9999';
      div.style.maxWidth = '50vw'; div.style.background = 'rgba(80,0,0,0.8)'; div.style.padding = '8px 10px'; div.style.border = '1px solid #a44'; div.style.borderRadius = '6px';
      div.style.fontSize = '12px'; div.style.whiteSpace = 'pre-wrap'; div.textContent = `Unhandled rejection: ${e.reason}`;
      document.body.appendChild(div);
      console.error(e.reason);
    });

    let lastMs = performance.now();
    let prevCamQuat = camera.quaternion.clone();
    let reanchoredThisFrame = false;
    // Smoothed visual transform for TARS (render-only)
    const tarsVisual = { position: new THREE.Vector3() };
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const realDtSeconds = Math.max(0, (now - lastMs) / 1000);
      lastMs = now;

      updateAimBallInertia(realDtSeconds);

      // Convert to sim years and clamp step for stability with substeps
      let dtYears = (state.paused ? 0 : realDtSeconds * state.timeScaleYearsPerSec);
      const frameSimYears = dtYears;
      let remaining = dtYears;
      while (remaining > 0) {
        const step = Math.min(remaining, physics.maxDt);
        // Integrate all planets (Sun-planet gravity only)
        for (const p of planets) integrateSunGravityVerletBody(p, step);
        // TARS update
        updateTars(step);
        // Payload updates
        updatePayloads(step);
        // Asteroid updates
        updateAsteroids(step);
        state.simYears += step;
        remaining -= step;
      }

      // Visuals
      // Adjust render origin based on TARS world position (decoupled from camera)
      {
        const tarsWorldKm = new THREE.Vector3(
          tars.position.x * SCALE,
          tars.position.y * SCALE,
          tars.position.z * SCALE
        );
        const delta = tarsWorldKm.clone().sub(renderOrigin);
        if (delta.length() > RENDER_REANCHOR_KM) {
          renderOrigin.add(delta);
          // Preserve current view: move camera and controls target by -delta
          camera.position.sub(delta);
          controls.target.sub(delta);
          // Keep trails continuous by shifting their anchors by -delta (local space)
          tarsTrail.anchor.sub(delta);
          for (const pl of simObjects.payloads) if (pl.trail) pl.trail.anchor.sub(delta);
          for (const a of simObjects.asteroids) if (a.trail) a.trail.anchor.sub(delta);
          reanchoredThisFrame = true;
        }
      }
      // Ensure trail anchors are expressed in render-local coordinates each frame
      if (tarsTrail) {
        const localAnchor = tarsTrail.anchor.clone().sub(renderOrigin);
        tarsTrail.line.position.copy(localAnchor);
        if (tarsTrail.headLine) tarsTrail.headLine.position.copy(localAnchor);
      }
      for (const pl of simObjects.payloads) {
        if (pl.trail) {
          const localAnchor = pl.trail.anchor.clone().sub(renderOrigin);
          pl.trail.line.position.copy(localAnchor);
          if (pl.trail.headLine) pl.trail.headLine.position.copy(localAnchor);
        }
      }
      for (const a of simObjects.asteroids) {
        if (a.trail) {
          const localAnchor = a.trail.anchor.clone().sub(renderOrigin);
          a.trail.line.position.copy(localAnchor);
          if (a.trail.headLine) a.trail.headLine.position.copy(localAnchor);
        }
      }
      for (const p of planets) p.updateVisual();
      for (const p of simObjects.payloads) {
        p.mesh.position.set(
          p.position.x * SCALE - renderOrigin.x,
          p.position.y * SCALE - renderOrigin.y,
          p.position.z * SCALE - renderOrigin.z
        );
      }
      for (const a of simObjects.asteroids) {
        a.mesh.position.set(
          a.position.x * SCALE - renderOrigin.x,
          a.position.y * SCALE - renderOrigin.y,
          a.position.z * SCALE - renderOrigin.z
        );
      }
      // Align static visuals to render origin
      starfield.position.set(-renderOrigin.x, -renderOrigin.y, -renderOrigin.z);
      for (const g of orbitGuides) g.position.set(-renderOrigin.x, -renderOrigin.y, -renderOrigin.z);
      // Sun position is derived from its true world position each frame relative to render origin
      sun.position.set(
        0 - renderOrigin.x,
        0 - renderOrigin.y,
        0 - renderOrigin.z
      );

      // Exponential smoothing for TARS visual position (reduces jitter at low dt)
      const physicsLocal = new THREE.Vector3(
        tars.position.x * SCALE - renderOrigin.x,
        tars.position.y * SCALE - renderOrigin.y,
        tars.position.z * SCALE - renderOrigin.z
      );
      const smoothingTime = 0.0; // 0 = no positional smoothing
      if (smoothingTime <= 0) {
        tars.mesh.position.copy(physicsLocal);
      } else {
        const alpha = 1 - Math.exp(-realDtSeconds / Math.max(1e-6, smoothingTime));
        if (!Number.isFinite(tarsVisual.position.x)) tarsVisual.position.copy(physicsLocal);
        tarsVisual.position.lerp(physicsLocal, alpha);
        // Render TARS at smoothed position, but do not alter physics state
        tars.mesh.position.copy(tarsVisual.position);
      }
      if (state.showTrails) {
        // Trails follow unsmoothed physics to avoid smoothing error accumulation
        appendToTrail(tarsTrail, physicsLocal);
        if (tarsTrail.headPositions && tarsTrail.count > 0) {
          const hp = tarsTrail.headPositions;
          const lastIdx = (tarsTrail.count - 1) * 3;
          hp[0] = tarsTrail.positions[lastIdx+0];
          hp[1] = tarsTrail.positions[lastIdx+1];
          hp[2] = tarsTrail.positions[lastIdx+2];
          hp[3] = physicsLocal.x - tarsTrail.anchor.x;
          hp[4] = physicsLocal.y - tarsTrail.anchor.y;
          hp[5] = physicsLocal.z - tarsTrail.anchor.z;
          tarsTrail.headGeometry.attributes.position.needsUpdate = true;
          tarsTrail.headGeometry.setDrawRange(0, 2);
        }
      }

      for (const pl of simObjects.payloads) {
        const plLocal = new THREE.Vector3(
          pl.position.x * SCALE - renderOrigin.x,
          pl.position.y * SCALE - renderOrigin.y,
          pl.position.z * SCALE - renderOrigin.z
        );
        pl.mesh.position.copy(plLocal);
        if (state.showTrails) {
          appendToTrail(pl.trail, plLocal);
          if (pl.trail.headPositions && pl.trail.count > 0) {
            const hp = pl.trail.headPositions;
            const lastIdx = (pl.trail.count - 1) * 3;
            hp[0] = pl.trail.positions[lastIdx+0];
            hp[1] = pl.trail.positions[lastIdx+1];
            hp[2] = pl.trail.positions[lastIdx+2];
            hp[3] = plLocal.x - pl.trail.anchor.x;
            hp[4] = plLocal.y - pl.trail.anchor.y;
            hp[5] = plLocal.z - pl.trail.anchor.z;
            pl.trail.headGeometry.attributes.position.needsUpdate = true;
            pl.trail.headGeometry.setDrawRange(0, 2);
          }
        }
      }
      for (const a of simObjects.asteroids) {
        const aLocal = new THREE.Vector3(
          a.position.x * SCALE - renderOrigin.x,
          a.position.y * SCALE - renderOrigin.y,
          a.position.z * SCALE - renderOrigin.z
        );
        a.mesh.position.copy(aLocal);
        if (state.showTrails) {
          appendToTrail(a.trail, aLocal);
          if (a.trail.headPositions && a.trail.count > 0) {
            const hp = a.trail.headPositions;
            const lastIdx = (a.trail.count - 1) * 3;
            hp[0] = a.trail.positions[lastIdx+0];
            hp[1] = a.trail.positions[lastIdx+1];
            hp[2] = a.trail.positions[lastIdx+2];
            hp[3] = aLocal.x - a.trail.anchor.x;
            hp[4] = aLocal.y - a.trail.anchor.y;
            hp[5] = aLocal.z - a.trail.anchor.z;
            a.trail.headGeometry.attributes.position.needsUpdate = true;
            a.trail.headGeometry.setDrawRange(0, 2);
          }
        }
      }
      sun.rotation.y += 0.02; // slow spin for visual interest

      if (state.followTARS && state.focus) {
        const focusObj = nameToBody[state.focus];
        if (focusObj) {
          const targetPosition = new THREE.Vector3();
          // The position of the mesh is already in render units, so we use it directly
          focusObj.getWorldPosition(targetPosition);

          if (state.prevFollowTarget) {
            const delta = targetPosition.clone().sub(state.prevFollowTarget);
            camera.position.add(delta);
          }
          controls.target.copy(targetPosition);
          state.prevFollowTarget = targetPosition.clone();
        }
      }

      // Apply orientation and spin once per frame
      {
        // Vertical orientation: root points up, model faces Sun horizontally
        const up = new THREE.Vector3(0, 1, 0);
        const radialDir = tars.position.clone().normalize();
        const forward = new THREE.Vector3(radialDir.x, 0, radialDir.z);
        if (forward.lengthSq() < 1e-8) forward.set(1, 0, 0);
        forward.normalize();
        const right = new THREE.Vector3().crossVectors(up, forward).normalize();
        const m = new THREE.Matrix4();
        m.makeBasis(right, up, forward);
        const baseQuat = new THREE.Quaternion().setFromRotationMatrix(m);
        tars.mesh.setRotationFromQuaternion(baseQuat);
        
        // Spin geometry around spinNode's local Y so the disc remains vertical (tie to simulation time)
        tars.spinPhase = (tars.spinPhase + tars.spin * frameSimYears * YEAR_SECONDS) % (Math.PI * 2);
        const sn = tars.mesh.userData.spinNode;
        if (sn) { sn.rotation.y = tars.spinPhase; }
      }

      // Update controls
      controls.update(realDtSeconds);

      for (const label of allLabels) {
        const distance = camera.position.distanceTo(label.getWorldPosition(new THREE.Vector3()));
        const scale = distance * 0.05;
        label.scale.set(scale, scale, 1);
      }
      if (hitMarker.visible) {
        const distance = camera.position.distanceTo(hitMarker.position);
        const scale = distance * 0.01; // Adjust this factor for desired screen size
        hitMarker.scale.set(scale, scale, scale);
      }
      
      // If following, keep offset implicit; no overwrite to preserve user zoom/orbit
      // Redraw aim ball when camera rotates so the aimpoint remains consistent relative to screen center
      if (!camera.quaternion.equals(prevCamQuat)) {
        prevCamQuat.copy(camera.quaternion);
        if (!aimBallState.dragging) {
            updateAimBallFromWorldDir();
        }
        drawAimBall();
      }
      // Lazy-update preview visuals; compute HUD even if preview is off
      if (preview._accum == null) preview._accum = 0;
      preview._accum += realDtSeconds;
      if (preview.dirty || preview._accum > 0.2) {
        computePayloadPreview();
        preview._accum = 0;
      }
      if (preview.enabled) {
        // Recompute only when marked dirty or every ~0.2s of real time
        // visuals are shown by computePayloadPreview when enabled
      }
      updateHUD();
      // Render the scene
      renderer.render(scene, camera);
    }
    animate();
    
    // Thrust/DV helpers and bindings
    function tryApplyDv(dirVec, magnitudeAUPerYr) {
      const dvMps = magnitudeAUPerYr * (149597870700) / (365.25*24*3600);
      tars.lastExitVelocityMps = dvMps;
      tars.velocity.addScaledVector(dirVec, magnitudeAUPerYr);
    }
    function getOrthoBasis() {
      const epsilon = 1e-12;
      const rWorld = tars.position.clone();
      const vWorld = tars.velocity.clone();
      const rLen = rWorld.length();
      const vLen = vWorld.length();
      const radial = rLen > epsilon ? rWorld.multiplyScalar(1 / rLen) : new THREE.Vector3(1, 0, 0);
      const prograde = vLen > epsilon ? vWorld.multiplyScalar(1 / vLen) : new THREE.Vector3(-radial.z, 0, radial.x).normalize();
      let normal = new THREE.Vector3().crossVectors(rWorld, vWorld);
      if (normal.lengthSq() < epsilon * epsilon) {
        const up = new THREE.Vector3(0, 1, 0);
        normal = new THREE.Vector3().crossVectors(radial, up);
        if (normal.lengthSq() < epsilon * epsilon) {
          normal = new THREE.Vector3().crossVectors(radial, new THREE.Vector3(1, 0, 0));
        }
      }
      normal.normalize();
      return { prograde, normal, radial };
    }
    btnProg.onclick = () => { const { prograde } = getOrthoBasis(); tryApplyDv(prograde, DV); };
    btnRetro.onclick = () => { const { prograde } = getOrthoBasis(); tryApplyDv(prograde.multiplyScalar(-1), DV); };
    btnRadOut.onclick = () => { const { radial } = getOrthoBasis(); tryApplyDv(radial, DV); };
    btnRadIn.onclick = () => { const { radial } = getOrthoBasis(); tryApplyDv(radial.multiplyScalar(-1), DV); };
    btnNormUp.onclick = () => { const { normal } = getOrthoBasis(); tryApplyDv(normal, DV); };
    btnNormDn.onclick = () => { const { normal } = getOrthoBasis(); tryApplyDv(normal.multiplyScalar(-1), DV); };
    function resetTars() {
      tars.position.set(1.0, 0, 0.01);
      const r = Math.sqrt(tars.position.lengthSq());
      const v = Math.sqrt(physics.muSun / r);
      const dir = new THREE.Vector3(-tars.position.z, 0, tars.position.x).normalize();
      tars.velocity.copy(dir.multiplyScalar(v));
      tars.spin = 0;
      tars.lastExitVelocityMps = 0;
      // clear trail
      tarsTrail.count = 0; tarsTrail.geometry.setDrawRange(0, 0); tarsTrail._lastPos = null; tarsTrail._lastSimYears = null;
      // clear payloads and markers
      const payloadIds = simObjects.payloads.map(p => p.id);
      payloadIds.forEach(despawnById);
      const asteroidIds = simObjects.asteroids.map(a => a.id);
      asteroidIds.forEach(despawnById);
      const markerIds = simObjects.markers.map(m => m.id);
      markerIds.forEach(despawnById);
      // disable and clear preview
      if (preview && preview.payload && preview.payload.line) {
        preview.enabled = false;
        preview.payload.line.visible = false;
        preview.dirty = true;
      }
    }
    btnResetTars.onclick = resetTars;
  </script>
</body>
</html>


